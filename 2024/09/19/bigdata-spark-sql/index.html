<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spark - SQL | ByteCoding</title><meta name="author" content="zhongmingmao"><meta name="copyright" content="zhongmingmao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="历史Hive 一开始，Hadoop&#x2F;MapReduce 在企业生产中大量使用，在 HDFS 上积累了大量数据 MapReduce 对于开发者而言使用难度较大，大部分开发人员最熟悉的还是传统的关系型数据库 为了方便大多数开发人员使用 Hadoop，诞生了 Hive Hive 提供类似 SQL 的编程接口，HQL 经过语法解析、逻辑计划、物理计划转化成 MapReduce 程序执行 使得开发">
<meta property="og:type" content="article">
<meta property="og:title" content="Spark - SQL">
<meta property="og:url" content="https://blog.zhongmingmao.top/2024/09/19/bigdata-spark-sql/index.html">
<meta property="og:site_name" content="ByteCoding">
<meta property="og:description" content="历史Hive 一开始，Hadoop&#x2F;MapReduce 在企业生产中大量使用，在 HDFS 上积累了大量数据 MapReduce 对于开发者而言使用难度较大，大部分开发人员最熟悉的还是传统的关系型数据库 为了方便大多数开发人员使用 Hadoop，诞生了 Hive Hive 提供类似 SQL 的编程接口，HQL 经过语法解析、逻辑计划、物理计划转化成 MapReduce 程序执行 使得开发">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-sql.webp">
<meta property="article:published_time" content="2024-09-18T16:06:25.000Z">
<meta property="article:modified_time" content="2024-11-18T08:12:39.644Z">
<meta property="article:author" content="zhongmingmao">
<meta property="article:tag" content="Big Data">
<meta property="article:tag" content="Spark">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-sql.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Spark - SQL",
  "url": "https://blog.zhongmingmao.top/2024/09/19/bigdata-spark-sql/",
  "image": "https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-sql.webp",
  "datePublished": "2024-09-18T16:06:25.000Z",
  "dateModified": "2024-11-18T08:12:39.644Z",
  "author": [
    {
      "@type": "Person",
      "name": "zhongmingmao",
      "url": "https://blog.zhongmingmao.top"
    }
  ]
}</script><link rel="shortcut icon" href="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/z.png"><link rel="canonical" href="https://blog.zhongmingmao.top/2024/09/19/bigdata-spark-sql/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":32,"languages":{"author":"Author: zhongmingmao","link":"Link: ","source":"Source: ByteCoding","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spark - SQL',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ByteCoding" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/url(https:/cdn.pixabay.com/photo/2021/07/20/03/39/fisherman-6479663_1280.jpg));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/z.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">639</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">83</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-sql.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ByteCoding</span></a><a class="nav-page-title" href="/"><span class="site-name">Spark - SQL</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Spark - SQL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2024-09-18T16:06:25.000Z" title="Created 2024-09-19 00:06:25">2024-09-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/big-data/">Big Data</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/big-data/spark/">Spark</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">1.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>5mins</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:512,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2024-11-18 16:12:39&quot;}" hidden></div><h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><ol>
<li>一开始，<strong>Hadoop&#x2F;MapReduce</strong> 在企业生产中大量使用，在 <strong>HDFS</strong> 上积累了大量数据</li>
<li><strong>MapReduce</strong> 对于开发者而言<strong>使用难度</strong>较大，大部分开发人员最熟悉的还是<strong>传统的关系型数据库</strong></li>
<li>为了方便大多数开发人员使用 Hadoop，诞生了 <strong>Hive</strong></li>
<li>Hive 提供类似 <strong>SQL</strong> 的编程接口，<strong>HQL</strong> 经过<strong>语法解析</strong>、<strong>逻辑计划</strong>、<strong>物理计划</strong>转化成 <strong>MapReduce</strong> 程序执行<ul>
<li>使得开发人员很容易对 <strong>HDFS</strong> 上存储的数据进行<strong>查询</strong>和<strong>分析</strong></li>
</ul>
</li>
</ol>
<span id="more"></span>

<h2 id="Shark"><a href="#Shark" class="headerlink" title="Shark"></a>Shark</h2><ol>
<li>在 Spark 刚问世时，Spark 团队开发了 <strong>Shark</strong> 来支持用 <strong>SQL</strong> 来查询 <strong>Spark</strong> 的数据</li>
<li>Shark 的本质是 <strong>Hive</strong>，Shark 修改了 Hive 的<strong>内存管理模块</strong>，大幅优化了<strong>运行速度</strong></li>
<li>Shark <strong>依赖</strong>于 Hive，严重影响了 Spark 的发展，Spark 要定义一个<strong>统一的技术栈</strong>和<strong>完整的生态</strong></li>
<li>依赖于 Hive 还会制约 Spark 各个组件的<strong>相互集成</strong>，Spark 无法利用 Spark 的特性进行<strong>深度优化</strong></li>
<li>2014 年 7 月 1 日，Spark 团队将 <strong>Shark</strong> 交给 <strong>Hive</strong> 进行管理，即 <strong>Hive on Spark</strong>，转而开发 <strong>Spark SQL</strong></li>
</ol>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/image-20241118100607648.png" alt="image-20241118100607648"></p>
<h2 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h2><ol>
<li>Spark SQL 摒弃了 Shark 的执行引擎，换成<strong>重新开发的执行引擎</strong></li>
<li>Spark SQL 不仅将<strong>关系型数据库的处理模式</strong>和 <strong>Spark 的函数式编程</strong>相结合<ul>
<li>还兼容多种数据格式 - Hive、RDD、JSON 文件、CSV 文件等</li>
</ul>
</li>
<li>Spark SQL 大大加快了 Spark 生态的发展</li>
</ol>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/image-20241118101250721.png" alt="image-20241118101250721"></p>
<ol>
<li>Spark SQL 本质上是一个 <strong>Library</strong>，运行在 <strong>Spark</strong> 的<strong>核心执行引擎</strong>之上</li>
<li>Spark SQL 提供类似于 <strong>SQL</strong> 的操作接口<ul>
<li>允许<strong>数据仓库应用</strong>直接获取数据</li>
<li>允许使用者通过<strong>命令行</strong>操作来<strong>交互</strong>地查询数据</li>
<li>还提供两个 API - <strong>DataFrame</strong> API + <strong>DataSet</strong> API<ul>
<li><strong>Java</strong>、<strong>Python</strong> 和 <strong>Scala</strong> 应用程序可以通过这两个 API 来读取和写入 RDD</li>
</ul>
</li>
</ul>
</li>
<li>应用程序还可以<strong>直接操作</strong> RDD</li>
<li>使用 Spark SQL，开发者会觉得好像在操作一个<strong>关系型数据库</strong>一样，而不是在操作 <strong>RDD</strong></li>
<li>与基本的 <strong>Spark RDD API</strong> 不同，Spark SQL 的接口提供了关于<strong>数据结构</strong>和<strong>正在执行的计算</strong>的更多信息<ul>
<li>在内部，Spark SQL 使用这些<strong>额外的信息</strong>来执行<strong>额外的优化</strong></li>
</ul>
</li>
<li>Spark SQL 支持<strong>多种交互方式</strong>，但在<strong>计算结果</strong>时均使用<strong>相同的执行引擎</strong>，可以在不同 API 之间<strong>来回切换</strong></li>
</ol>
<h2 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h2><ol>
<li>DataSet 即<strong>数据集</strong>，是 <strong>Spark 1.6</strong> 新引入的接口</li>
<li>与 RDD 类似，DataSet 也是<strong>不可变分布式的数据单元</strong><ul>
<li>既有与 RDD 类似的各类<strong>转换</strong>和<strong>动作</strong>函数的定义</li>
<li>还享受 Spark SQL <strong>优化过的执行引擎</strong>，使得<strong>数据搜索效率更高</strong></li>
</ul>
</li>
<li>DataSet 支持的<strong>转换</strong>和<strong>动作</strong>与 RDD 类似 - map、filter、count 等</li>
<li>与 RDD 类似，DataSet 上的<strong>转换</strong>操作<strong>不会被立即执行</strong><ul>
<li>先<strong>生成新的 DataSet</strong>，只有遇到<strong>动作</strong>操作，才会把之前的转换操作<strong>一并执行</strong>，生成结果</li>
</ul>
</li>
<li>DataSet 的内部结构包含了<strong>逻辑计划</strong>，即<strong>生成该数据集所需要的运算</strong><ul>
<li>当<strong>动作</strong>操作执行时，Spark SQL 的<strong>查询优化器</strong>会<strong>优化该逻辑计划</strong></li>
<li>并生成一个可以<strong>分布式执行</strong>、包含<strong>分区信息</strong>的<strong>物理计划</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>DataSet vs RDD</p>
</blockquote>
<ol>
<li><strong>DataSet API</strong> 是 <strong>Spark SQL</strong> 的一个组件，DataSet 具有<strong>关系型</strong>数据库表中的<strong>特性</strong></li>
<li>DataSet 所描述的数据都被组织到<strong>有名字的列</strong>中，就像关系型数据库中的<strong>表</strong>一样</li>
</ol>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/image-20241118103637661.png" alt="image-20241118103637661"></p>
<ol>
<li><strong>RDD</strong> 以 People 为类型参数，但 Spark 框架本身<strong>并不了解</strong> People 类的<strong>内部结构</strong>，所有操作都以 People 为<strong>单位</strong></li>
<li><strong>DataSet</strong> 提供详细的<strong>结构信息</strong>和每列的<strong>数据类型</strong><ul>
<li>DataSet 为 Spark SQL 提供了<strong>数据表</strong>的 <strong>Schema</strong> 信息，使得 DataSet API 的<strong>执行效率更高</strong></li>
<li>由于 DataSet 存储了每列的数据类型，在<strong>程序编译</strong>时可以执行<strong>类型检测</strong></li>
</ul>
</li>
</ol>
<h2 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h2><ol>
<li>DataFrame 是一种<strong>特殊的 DataSet</strong><ul>
<li>DataFrame 也是<strong>关系型数据库</strong>中<strong>表</strong>一样的<strong>结构化存储机制</strong>，也是<strong>分布式不可变</strong>的数据结构</li>
</ul>
</li>
<li>但 DataFrame 的<strong>每一列并不存储类型信息</strong>，所以在<strong>编译过程</strong>并不能发现<strong>类型错误</strong><ul>
<li>DataFrame 每一<strong>行</strong>的<strong>类型</strong>固定为 <strong>Row</strong>，可以被当作 <strong>DataSet[Row]</strong> 来处理</li>
<li>必须要通过<strong>解析</strong>才能获取到<strong>各列的值</strong> - 类似于某些 JSON 库的处理<ul>
<li>DataSet - people.name</li>
<li>DataFrame - <code>people.get As [String](&quot;name&quot;)</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="RDD-DataFrame-DataSet"><a href="#RDD-DataFrame-DataSet" class="headerlink" title="RDD &#x2F; DataFrame &#x2F; DataSet"></a>RDD &#x2F; DataFrame &#x2F; DataSet</h2><table>
<thead>
<tr>
<th></th>
<th>RDD</th>
<th>DataFrame</th>
<th>DataSet</th>
</tr>
</thead>
<tbody><tr>
<td>不可变性</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>分区</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Schema</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>查询优化器</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>API 级别</td>
<td>低</td>
<td>高（底层基于 RDD 实现）</td>
<td>高（DataFrame 的拓展）</td>
</tr>
<tr>
<td>是否存储类型</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>何时检测语法错误</td>
<td>编译时</td>
<td>编译时</td>
<td>编译时</td>
</tr>
<tr>
<td>何时检测分析错误</td>
<td>编译时</td>
<td>运行时</td>
<td>编译时</td>
</tr>
</tbody></table>
<h3 id="历史-1"><a href="#历史-1" class="headerlink" title="历史"></a>历史</h3><ol>
<li><strong>RDD API</strong> 在 <strong>Spark 1.x</strong> 中就已经存在，是整个 Spark 框架的基石</li>
<li>为了方便熟悉<strong>关系型数据</strong>和 <strong>SQL</strong> 的开发人员使用，在 RDD 的基础上，Spark 创建了 <strong>DataFrame</strong> API</li>
<li>从 <strong>Spark 1.6</strong> 开始，引入了 <strong>DataSet</strong>，在 <strong>DataFrame</strong> 的基础上，新增了对数据的每一列的<strong>数据类型</strong>的限制</li>
<li>在 <strong>Spark 2.0</strong> 中，<strong>DataFrame</strong> 和 <strong>DataSet</strong> 被<strong>统一</strong>，DataFrame 作为 <strong>DataSet[Row]</strong> 存在<ul>
<li>在<strong>弱类型</strong>的语言中，如 <strong>Python</strong> 中的 <strong>DataFrame API</strong> 依然存在</li>
<li>在<strong>强类型</strong>的语言中，如 <strong>Java</strong> 中的 <strong>DataFrame API</strong> 已经不复存在</li>
</ul>
</li>
</ol>
<h3 id="不可变性-分区"><a href="#不可变性-分区" class="headerlink" title="不可变性 + 分区"></a>不可变性 + 分区</h3><ol>
<li>DataFrame 和 DataSet 都是<strong>基于 RDD</strong>，都拥有 RDD 的基本特性</li>
<li>可以通过简单的 API 在 DataFrame 或 DataSet 与 RDD 之间进行<strong>无缝切换</strong></li>
</ol>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ol>
<li>DataFrame 和 DataSet 的性能要比 RDD 更好</li>
<li>Spark 程序运行时，Spark SQL 中的<strong>查询优化器</strong>会对语句进行<strong>分析</strong>，并生成<strong>优化过的 RDD</strong> 在底层执行</li>
</ol>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/image-20241118153550196.png" alt="image-20241118153550196"></p>
<h3 id="错误检测"><a href="#错误检测" class="headerlink" title="错误检测"></a>错误检测</h3><ol>
<li><strong>RDD</strong> 和 <strong>DataSet</strong> 都是<strong>类型安全</strong>的，而 DataFrame 并<strong>不是类型安全</strong>的（并不存储每一列的信息）</li>
<li>使用 <strong>DataFrame</strong> API 时，可以选择一个并<strong>不存在的列</strong>，该错误只有在代码被<strong>执行时</strong>才会抛出<ul>
<li>使用 <strong>DataSet</strong> API，在<strong>编译时</strong>就能检测到这个错误</li>
</ul>
</li>
</ol>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol>
<li>DataFrame 和 DataSet 是 Spark SQL 提供的基于 <strong>RDD</strong> 的<strong>结构化数据抽象</strong><ul>
<li>既有 RDD <strong>不可变</strong>、<strong>分区</strong>、<strong>存储依赖关系</strong>等特性</li>
<li>又拥有类似于<strong>关系型数据库</strong>的<strong>结构化信息</strong></li>
</ul>
</li>
<li>基于 DataFrame 和 DataSet API 开发的程序会被<strong>自动优化</strong><ul>
<li>无需开发人员操作<strong>底层</strong>的 <strong>RDD API</strong> 来进行<strong>手动优化</strong>，大大提升开发效率</li>
</ul>
</li>
<li><strong>RDD API</strong> 对于<strong>非结构化</strong>的数据处理有独特的优势，并且更方便做<strong>底层</strong>操作</li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://blog.zhongmingmao.top">zhongmingmao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://blog.zhongmingmao.top/2024/09/19/bigdata-spark-sql/">https://blog.zhongmingmao.top/2024/09/19/bigdata-spark-sql/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/big-data/">Big Data</a><a class="post-meta__tags" href="/tags/spark/">Spark</a></div><div class="post-share"><div class="social-share" data-image="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-sql.webp" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/09/20/bigdata-spark-streaming/" title="Spark - Streaming"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-streaming.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Spark - Streaming</div></div><div class="info-2"><div class="info-item-1">流处理 Spark SQL 中的 DataFrame API 和 DataSet API 都是基于批处理模式对静态数据进行处理 在 2013，Spark 的流处理组件 Spark Streaming 发布，现在的 Spark Streaming 已经非常成熟，应用非常广泛    原理 Spark Streaming 的原理与微积分的思想很类似 微分是无限细分，而积分是对无限细分的每一段进行求和 本质 - 将一个连续的问题转换成了无限个离散的问题   流处理的数据是一系列连续不断变化，且无边界的，永远无法预测下一秒的数据 Spark Streaming 用时间片拆分了无限的数据流 然后对每个数据片用类似于批处理的方法进行处理，输出的数据也是分块的      Spark Streaming 提供一个对于流数据的抽象 DStream DStream 可以由 Kafka、Flume 或者 HDFS 的流数据生成，也可以由别的 DStream 经过各种转换操作得到 底层 DStream 由多个序列化的 RDD 构成，按时间片（如一秒）切分成的每个数据单位都是一个 RDD Spark 核心引擎将对 DStream ...</div></div></div></a><a class="pagination-related" href="/2024/09/18/bigdata-spark-rdd/" title="Spark - RDD"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-rdd.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Spark - RDD</div></div><div class="info-2"><div class="info-item-1">分布式内存 传统的 MapReduce 框架运行缓慢，主要原因是 DAG 的中间计算结果需要写入硬盘来防止运行结果丢失 每次调用中间计算结果都需要进行一次硬盘的读取 反复对硬盘进行读写操作以及潜在的数据复制和序列化操作会大大地提高了计算延迟   新的分布式存储方案 - 保持之前系统的稳定性、错误恢复和可扩展性，并尽可能地减少硬盘 IO 操作 RDD 是基于分布式内存的数据抽象，不仅支持基于工作集的应用，同时具有数据流模型的特点      定义分区 分区代表同一个 RDD 包含的数据被存储在系统的不同节点上，这是可以被并行处理的前提 在逻辑上，可以认为 RDD 是一个大数组，数组中的每个元素代表一个分区（Partition） 在物理存储中，每个分区指向一个存放在内存或者硬盘中的数据块（Block） Block 是独立的，可以被存放在分布式系统中的不同节点   RDD 只是抽象意义的数据集合，分区内部并不会存储具体的数据    RDD 中的每个分区都有它在该 RDD 中的 Index 通过 RDD_ID 和 Partition_Index 可以唯一确定对应 Block 的编号 从而通过底层存储层的接口中提取...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/09/22/bigdata-spark-flink/" title="Big Data - Spark + Flink"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-flink.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-22</div><div class="info-item-2">Big Data - Spark + Flink</div></div><div class="info-2"><div class="info-item-1">Spark 实时性 无论是 Spark Streaming 还是 Structured Streaming，Spark 流处理的实时性还不够 无法应对实时性要求很高的流处理场景   Spark 的流处理是基于微批处理的思想 把流处理看做批处理的一种特殊形式，没接收到一个时间间隔的数据才会去处理   虽然在 Spark 2.3 中提出连续处理模型，但只支持有限的功能，并不能在大项目中使用 要在流处理的实时性提升，就不能继续用微批处理的模式，而是有数据数据就立即处理，不做等待 Apache Flink 采用了基于操作符（Operator）的连续流模型，可以做到微秒级别的延迟      Flink模型 Flink 中最核心的数据结构是 Stream，代表一个运行在多个分区上的并行流 在 Stream 上可以进行各种转换（Transformation）操作 与 Spark RDD 不同的是，Stream 代表一个数据流而不是静态数据的集合 Stream 所包含的数据随着时间增长而变化的 而且 Stream 上的转换操作都是逐条进行的 - 每当有新数据进入，整个流程都会被执行并更新结果 Flink 比 Spark...</div></div></div></a><a class="pagination-related" href="/2024/09/21/bigdata-spark-structured-streaming/" title="Spark - Structured Streaming"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-structured-streaming.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-21</div><div class="info-item-2">Spark - Structured Streaming</div></div><div class="info-2"><div class="info-item-1">背景 Spark Streaming 将无边界的流数据抽象成 DStream 按特定的时间间隔，把数据流分割成一个个 RDD 进行批处理 DStream API 与 RDD API 高度相似，拥有 RDD 的各种性质   DataSet&#x2F;DataFrame DataSet&#x2F;DataFrame 是高级 API，提供类似于 SQL 的查询接口，方便熟悉关系型数据库的开发人员使用 Spark SQL 执行引擎会自动优化 DataSet&#x2F;DataFrame 程序 用 RDD API 开发的程序本质上需要开发人员手工构造 RDD 的 DAG 执行图，依赖于手工优化     如果拥有 DataSet&#x2F;DataFrame API 的流处理模块 无需去用相对底层的 DStream API 去处理无边界数据，大大提升开发效率   在 2016 年，Spark 2.0 中推出结构化流处理的模块 - Structured Streaming Structured Streaming 基于 Spark SQL 引擎实现 在开发视角，流数据和静态数据没有区别，可以像批处理静态数据那样处理流...</div></div></div></a><a class="pagination-related" href="/2024/09/20/bigdata-spark-streaming/" title="Spark - Streaming"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-streaming.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-20</div><div class="info-item-2">Spark - Streaming</div></div><div class="info-2"><div class="info-item-1">流处理 Spark SQL 中的 DataFrame API 和 DataSet API 都是基于批处理模式对静态数据进行处理 在 2013，Spark 的流处理组件 Spark Streaming 发布，现在的 Spark Streaming 已经非常成熟，应用非常广泛    原理 Spark Streaming 的原理与微积分的思想很类似 微分是无限细分，而积分是对无限细分的每一段进行求和 本质 - 将一个连续的问题转换成了无限个离散的问题   流处理的数据是一系列连续不断变化，且无边界的，永远无法预测下一秒的数据 Spark Streaming 用时间片拆分了无限的数据流 然后对每个数据片用类似于批处理的方法进行处理，输出的数据也是分块的      Spark Streaming 提供一个对于流数据的抽象 DStream DStream 可以由 Kafka、Flume 或者 HDFS 的流数据生成，也可以由别的 DStream 经过各种转换操作得到 底层 DStream 由多个序列化的 RDD 构成，按时间片（如一秒）切分成的每个数据单位都是一个 RDD Spark 核心引擎将对 DStream ...</div></div></div></a><a class="pagination-related" href="/2024/09/18/bigdata-spark-rdd/" title="Spark - RDD"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-rdd.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-18</div><div class="info-item-2">Spark - RDD</div></div><div class="info-2"><div class="info-item-1">分布式内存 传统的 MapReduce 框架运行缓慢，主要原因是 DAG 的中间计算结果需要写入硬盘来防止运行结果丢失 每次调用中间计算结果都需要进行一次硬盘的读取 反复对硬盘进行读写操作以及潜在的数据复制和序列化操作会大大地提高了计算延迟   新的分布式存储方案 - 保持之前系统的稳定性、错误恢复和可扩展性，并尽可能地减少硬盘 IO 操作 RDD 是基于分布式内存的数据抽象，不仅支持基于工作集的应用，同时具有数据流模型的特点      定义分区 分区代表同一个 RDD 包含的数据被存储在系统的不同节点上，这是可以被并行处理的前提 在逻辑上，可以认为 RDD 是一个大数组，数组中的每个元素代表一个分区（Partition） 在物理存储中，每个分区指向一个存放在内存或者硬盘中的数据块（Block） Block 是独立的，可以被存放在分布式系统中的不同节点   RDD 只是抽象意义的数据集合，分区内部并不会存储具体的数据    RDD 中的每个分区都有它在该 RDD 中的 Index 通过 RDD_ID 和 Partition_Index 可以唯一确定对应 Block 的编号 从而通过底层存储层的接口中提取...</div></div></div></a><a class="pagination-related" href="/2024/09/17/bigdata-spark-overview/" title="Spark - Overview"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-17</div><div class="info-item-2">Spark - Overview</div></div><div class="info-2"><div class="info-item-1">MapReduce概述 MapReduce 通过简单的 Map 和 Reduce 的抽象提供了一个编程模型 可以在一个由上百台机器组成的集群上并发处理大量的数据集，而把计算细节隐藏起来   各种各样的复杂数据处理都可以分解为 Map 和 Reduce 的基本元素 复杂的数据处理可以分解成由多个 Job（包含一个 Mapper 和一个 Reducer）组成的 DAG 然后，将每个 Mapper 和 Reducer 放到 Hadoop 集群上执行，得到最终结果      不足 高昂的维护成本 时间性能不达标 MapReduce 模型的抽象层次低 大量的底层逻辑需要开发者手工完成 - 用汇编语言开发游戏   只提供 Map 和 Reduce 操作 很多现实的数据处理场景并不适合用这个模型来描述 实现复杂的操作需要技巧，让整个工程变得庞大且难以维护 维护一个多任务协调的状态机成本很高，且扩展性很差   在 Hadoop 中，每个 Job 的计算结果都会存储在 HDFS 文件存储系统中 每一步计算都要进行硬盘的读取和写入，大大增加了系统的延迟   MapReduce 对于迭代算法的处理性能很差，而且非常耗资源 因...</div></div></div></a><a class="pagination-related" href="/2024/10/05/bigdata-beam-future/" title="Beam - Future"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/flink-runner-beam-beam-vision.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-05</div><div class="info-item-2">Beam - Future</div></div><div class="info-2"><div class="info-item-1">技术迭代 2006，Apache Hadoop 发布，基于 MapReduce 计算模型 2009，Spark 计算框架在 加州伯克利大学诞生，于 2010 年开源，于 2014 年成为 Apache 的顶级项目 Spark 的数据处理效率远在 Hadoop 之上   2014，Flink 面世，流批一体，于 2018 年被阿里收购    Apache Beam Apache Beam 根据 Dataflow Model API 实现的，能完全胜任批流一体的任务 Apache Beam 有中间的抽象转换层，工程师无需学习新 Runner 的 API 的语法，减少学习新技术的时间成本 Runner 可以专心优化效率和迭代功能，而不必担心迁移  Beam Runner 迭代非常快 - 如 Flink  </div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/z.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">zhongmingmao</div><div class="author-info-description">Focus on Infrastructure.</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">639</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">83</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="mailto:zhongmingmao0625@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Things are always unexpected!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2"><span class="toc-number">1.</span> <span class="toc-text">历史</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hive"><span class="toc-number">1.1.</span> <span class="toc-text">Hive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shark"><span class="toc-number">1.2.</span> <span class="toc-text">Shark</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spark-SQL"><span class="toc-number">1.3.</span> <span class="toc-text">Spark SQL</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DataSet"><span class="toc-number">2.1.</span> <span class="toc-text">DataSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DataFrame"><span class="toc-number">2.2.</span> <span class="toc-text">DataFrame</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDD-DataFrame-DataSet"><span class="toc-number">2.3.</span> <span class="toc-text">RDD &#x2F; DataFrame &#x2F; DataSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7-%E5%88%86%E5%8C%BA"><span class="toc-number">2.3.2.</span> <span class="toc-text">不可变性 + 分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">2.3.3.</span> <span class="toc-text">性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B"><span class="toc-number">2.3.4.</span> <span class="toc-text">错误检测</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/21/cloud-native-observability-opentelemetry-java-zero-code/" title="Observability - OpenTelemetry Java Zero Code"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://observability-1253868755.cos.ap-guangzhou.myqcloud.com/otel-java-agent.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Observability - OpenTelemetry Java Zero Code"/></a><div class="content"><a class="title" href="/2025/01/21/cloud-native-observability-opentelemetry-java-zero-code/" title="Observability - OpenTelemetry Java Zero Code">Observability - OpenTelemetry Java Zero Code</a><time datetime="2025-01-20T16:06:25.000Z" title="Created 2025-01-21 00:06:25">2025-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/20/cloud-native-observability-opentelemetry-java/" title="Observability - OpenTelemetry Java"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://observability-1253868755.cos.ap-guangzhou.myqcloud.com/otel-java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Observability - OpenTelemetry Java"/></a><div class="content"><a class="title" href="/2025/01/20/cloud-native-observability-opentelemetry-java/" title="Observability - OpenTelemetry Java">Observability - OpenTelemetry Java</a><time datetime="2025-01-19T16:06:25.000Z" title="Created 2025-01-20 00:06:25">2025-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/19/ai-agent-overview-mcp/" title="AI Agent - MCP Overview"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ai-agent-1253868755.cos.ap-guangzhou.myqcloud.com/mcp.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI Agent - MCP Overview"/></a><div class="content"><a class="title" href="/2025/01/19/ai-agent-overview-mcp/" title="AI Agent - MCP Overview">AI Agent - MCP Overview</a><time datetime="2025-01-18T16:06:25.000Z" title="Created 2025-01-19 00:06:25">2025-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/18/ai-agent-overview/" title="AI Agent - Overview"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ai-agent-1253868755.cos.ap-guangzhou.myqcloud.com/ai-agent.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI Agent - Overview"/></a><div class="content"><a class="title" href="/2025/01/18/ai-agent-overview/" title="AI Agent - Overview">AI Agent - Overview</a><time datetime="2025-01-17T16:06:25.000Z" title="Created 2025-01-18 00:06:25">2025-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/17/new-java-feature-foreign-function-api/" title="New Java Feature - Foreign Function API"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://java-feature-1253868755.cos.ap-guangzhou.myqcloud.com/Java-Foreign-Function-API.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="New Java Feature - Foreign Function API"/></a><div class="content"><a class="title" href="/2025/01/17/new-java-feature-foreign-function-api/" title="New Java Feature - Foreign Function API">New Java Feature - Foreign Function API</a><time datetime="2025-01-16T16:06:25.000Z" title="Created 2025-01-17 00:06:25">2025-01-17</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2015 - 2025 By zhongmingmao</span></div><div class="footer_custom_text">Life is like a box of chocolates. You can't know what you'll eat until you open it.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div></body></html>