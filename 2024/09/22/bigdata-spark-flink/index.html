<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Big Data - Spark + Flink | ByteCoding</title><meta name="author" content="zhongmingmao"><meta name="copyright" content="zhongmingmao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="Spark 实时性 无论是 Spark Streaming 还是 Structured Streaming，Spark 流处理的实时性还不够 无法应对实时性要求很高的流处理场景   Spark 的流处理是基于微批处理的思想 把流处理看做批处理的一种特殊形式，没接收到一个时间间隔的数据才会去处理   虽然在 Spark 2.3 中提出连续处理模型，但只支持有限的功能，并不能在大项目中使用 要在流处理">
<meta property="og:type" content="article">
<meta property="og:title" content="Big Data - Spark + Flink">
<meta property="og:url" content="https://blog.zhongmingmao.top/2024/09/22/bigdata-spark-flink/index.html">
<meta property="og:site_name" content="ByteCoding">
<meta property="og:description" content="Spark 实时性 无论是 Spark Streaming 还是 Structured Streaming，Spark 流处理的实时性还不够 无法应对实时性要求很高的流处理场景   Spark 的流处理是基于微批处理的思想 把流处理看做批处理的一种特殊形式，没接收到一个时间间隔的数据才会去处理   虽然在 Spark 2.3 中提出连续处理模型，但只支持有限的功能，并不能在大项目中使用 要在流处理">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-flink.jpeg">
<meta property="article:published_time" content="2024-09-21T16:06:25.000Z">
<meta property="article:modified_time" content="2024-11-18T16:34:55.538Z">
<meta property="article:author" content="zhongmingmao">
<meta property="article:tag" content="Big Data">
<meta property="article:tag" content="Spark">
<meta property="article:tag" content="Flink">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-flink.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Big Data - Spark + Flink",
  "url": "https://blog.zhongmingmao.top/2024/09/22/bigdata-spark-flink/",
  "image": "https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-flink.jpeg",
  "datePublished": "2024-09-21T16:06:25.000Z",
  "dateModified": "2024-11-18T16:34:55.538Z",
  "author": [
    {
      "@type": "Person",
      "name": "zhongmingmao",
      "url": "https://blog.zhongmingmao.top"
    }
  ]
}</script><link rel="shortcut icon" href="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/z.png"><link rel="canonical" href="https://blog.zhongmingmao.top/2024/09/22/bigdata-spark-flink/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":32,"languages":{"author":"Author: zhongmingmao","link":"Link: ","source":"Source: ByteCoding","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Big Data - Spark + Flink',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ByteCoding" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/url(https:/cdn.pixabay.com/photo/2021/07/20/03/39/fisherman-6479663_1280.jpg));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/z.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">639</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">83</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-flink.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ByteCoding</span></a><a class="nav-page-title" href="/"><span class="site-name">Big Data - Spark + Flink</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Big Data - Spark + Flink</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2024-09-21T16:06:25.000Z" title="Created 2024-09-22 00:06:25">2024-09-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/big-data/">Big Data</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/big-data/spark/">Spark</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">1.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>4mins</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:512,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2024-11-19 00:34:55&quot;}" hidden></div><h1 id="Spark-实时性"><a href="#Spark-实时性" class="headerlink" title="Spark 实时性"></a>Spark 实时性</h1><ol>
<li>无论是 <strong>Spark Streaming</strong> 还是 <strong>Structured Streaming</strong>，Spark <strong>流处理</strong>的<strong>实时性还不够</strong><ul>
<li>无法应对<strong>实时性要求很高</strong>的流处理场景</li>
</ul>
</li>
<li>Spark 的<strong>流处理</strong>是基于<strong>微批处理</strong>的思想<ul>
<li>把流处理看做批处理的一种特殊形式，没接收到一个<strong>时间间隔</strong>的数据才会去处理</li>
</ul>
</li>
<li>虽然在 Spark 2.3 中提出<strong>连续处理模型</strong>，但只支持<strong>有限的功能</strong>，并不能在大项目中使用</li>
<li>要在流处理的<strong>实时性</strong>提升，就不能继续用<strong>微批处理</strong>的模式，而是有数据数据就<strong>立即处理</strong>，不做等待<ul>
<li>Apache <strong>Flink</strong> 采用了基于操作符（<strong>Operator</strong>）的<strong>连续流模型</strong>，可以做到<strong>微秒级别</strong>的延迟</li>
</ul>
</li>
</ol>
<span id="more"></span>

<h1 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h1><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><ol>
<li>Flink 中最核心的数据结构是 <strong>Stream</strong>，代表一个运行在<strong>多个分区</strong>上的<strong>并行流</strong></li>
<li>在 <strong>Stream</strong> 上可以进行各种<strong>转换</strong>（<strong>Transformation</strong>）操作</li>
<li>与 Spark RDD 不同的是，<strong>Stream</strong> 代表一个<strong>数据流</strong>而不是<strong>静态数据的集合</strong><ul>
<li><strong>Stream</strong> 所包含的数据随着<strong>时间增长</strong>而<strong>变化</strong>的</li>
<li>而且 Stream 上的<strong>转换</strong>操作都是<strong>逐条</strong>进行的 - 每当有<strong>新数据</strong>进入，整个流程都会被<strong>执行</strong>并<strong>更新</strong>结果</li>
<li>Flink 比 Spark Streaming 有<strong>更低的流处理延迟性</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>当一个 Flink 程序被执行时，会被映射为 <strong>Streaming Dataflow</strong></p>
</blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/image-20241118232520584.png" alt="image-20241118232520584"></p>
<ol>
<li>Streaming Dataflow 包括 <strong>Stream</strong> 和 <strong>Operator</strong></li>
<li>转换操作符（<strong>Transformation Operator</strong>）把<strong>一个或多个 Stream</strong> 转换成<strong>多个 Stream</strong></li>
<li>每个 Streaming Dataflow 都有一个输入数据源（<strong>Source</strong>）和一个输出数据源（<strong>Sink</strong>）</li>
<li><strong>Streaming Dataflow</strong> 与 <strong>Spark RDD DAG</strong> 类似，会被组合成一个 <strong>DAG</strong> 去执行</li>
</ol>
<blockquote>
<p>在 <strong>Flink</strong> 中，程序天生就是<strong>并行</strong>和<strong>分布式</strong>的</p>
</blockquote>
<ol>
<li>一个 <strong>Stream</strong> 可以包含<strong>多个</strong>分区（<strong>Stream Partitions</strong>）</li>
<li>一个 <strong>Operator</strong> 可以被分成多个 <strong>Operator 子任务</strong><ul>
<li>每一个子任务在<strong>不同的线程</strong>或者<strong>不同的节点</strong>上<strong>独立执行</strong></li>
</ul>
</li>
</ol>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/image-20241118233145416.png" alt="image-20241118233145416"></p>
<blockquote>
<p><strong>Stream</strong> 在 <strong>Operator</strong> 之间<strong>传输数据</strong>的形式有两种</p>
</blockquote>
<ol>
<li><strong>一对一</strong>（One-to-one）<ul>
<li>Stream 维护着<strong>分区</strong>和<strong>元素</strong>的<strong>顺序</strong></li>
<li><strong>Map Operator</strong> 的子任务<strong>处理</strong>的数据和 <strong>Source</strong> 的子任务<strong>生产</strong>的元素的数据相同</li>
<li>与 <strong>Spark RDD 窄依赖</strong>非常类似</li>
</ul>
</li>
<li><strong>重新分布</strong>（Redistributing）<ul>
<li>Stream 中数据的分区会发生<strong>改变</strong></li>
<li>Operator 的每个子任务把数据发送到不同的<strong>目标子任务</strong>上</li>
</ul>
</li>
</ol>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/image-20241118234718318.png" alt="image-20241118234718318"></p>
<ol>
<li>核心处理引擎是 <strong>Distributed Streaming Dataflow</strong><ul>
<li>所有高级 API 和应用库都会被翻译成包含 <strong>Stream</strong> 和 <strong>Operator</strong> 的 <strong>Streaming Dataflow</strong></li>
</ul>
</li>
<li>Flink 提供两个核心的 API - <strong>DataSet API</strong> 和 <strong>DataStream API</strong><ul>
<li>与 <strong>Spark</strong> 的 <strong>DataSet</strong> 和 <strong>DataFrame</strong> 非常类似</li>
<li><strong>DataSet</strong> 代表<strong>有界的数据集</strong>，而 <strong>DataStream</strong> 代表<strong>流数据</strong></li>
<li><strong>DataSet API</strong> 用来做<strong>批处理</strong>，而 <strong>DataStream API</strong> 用来做<strong>流处理</strong></li>
</ul>
</li>
<li>在 Flink 内部，<strong>DataSet</strong> 其实也是用 <strong>Stream</strong> 表示<ul>
<li><strong>静态的有界数据</strong>可以被看作<strong>特殊的流数据</strong> – 刚好与 <strong>Spark</strong> 相反</li>
<li><strong>DataSet</strong> 与 <strong>DataStream</strong> 可以<strong>无缝切换</strong> - Flink 的核心是 <strong>DataStream</strong></li>
</ul>
</li>
<li><strong>DataSet</strong> 和 <strong>DataStream</strong> 都支持各种基本的<strong>转换</strong>操作 - map、filter、count、groupBy 等</li>
<li>Flink 是用 <strong>Java</strong> 开发的，对 Java 有原生的支持，也可以用 <strong>Scala</strong> 开发 Flink 程序<ul>
<li>在 <strong>Flink 1.0</strong> 后支持了 <strong>Python</strong></li>
</ul>
</li>
<li><strong>Flink DataStream</strong> 的使用方法与 <strong>Spark RDD</strong> 类似<ul>
<li>把程序拆分成一系列的<strong>转换</strong>操作并<strong>分布式</strong>地执行</li>
</ul>
</li>
<li>在 <strong>DataSet</strong> 和 <strong>DataStream</strong> 之上，有更高层次的 <strong>Table</strong> API<ul>
<li><strong>Flink Table API</strong> 与 <strong>Spark SQL</strong> 的思想类似，是<strong>关系型</strong>的 API</li>
<li>可以像操作 <strong>SQL</strong> 数据库表那样操作数据，而不需要通过操作 <strong>DataStream&#x2F;DataSet</strong> 的方式进行数据处理</li>
<li>更不需要<strong>手动优化代码</strong>的执行逻辑</li>
<li>跟 <strong>Spark SQL</strong> 类似，<strong>Flink Table API</strong> 同样统一了 Flink 的<strong>批处理</strong>和<strong>流处理</strong></li>
</ul>
</li>
</ol>
<h1 id="Flink-vs-Spark"><a href="#Flink-vs-Spark" class="headerlink" title="Flink vs Spark"></a>Flink vs Spark</h1><blockquote>
<p><strong>Flink</strong> 和 <strong>Spark</strong> 都支持<strong>批处理</strong>和<strong>流处理</strong></p>
</blockquote>
<h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><ol>
<li>都是基于<strong>内存</strong>计算</li>
<li>都有<strong>统一</strong>的<strong>批处理</strong>和<strong>流处理</strong>的 API，都支持类似 <strong>SQL</strong> 的编程接口</li>
<li>都支持很多相同的<strong>转换</strong>操作，编程都是用类似 <strong>Scala Collection API</strong> 的<strong>函数式编程</strong>模式</li>
<li>都有<strong>完善的错误恢复机制</strong></li>
<li>都支持 <strong>Exactly once</strong> 的<strong>语义一致性</strong></li>
</ol>
<h2 id="差异点"><a href="#差异点" class="headerlink" title="差异点"></a>差异点</h2><h3 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h3><blockquote>
<p>Flink</p>
</blockquote>
<ol>
<li><strong>Spark</strong> 是基于<strong>微批处理</strong><ul>
<li>把<strong>流数据</strong>看成一个个小的<strong>批处理数据块</strong>分别处理，<strong>延迟性</strong>只能做到<strong>秒级</strong></li>
<li>Spark 只支持<strong>基于时间</strong>的<strong>窗口</strong>处理（<strong>处理时间</strong>或者<strong>事件时间</strong>）</li>
</ul>
</li>
<li><strong>Flink</strong> 是基于<strong>每个事件</strong>处理<ul>
<li>每当有新的数据输入都会<strong>立刻处理</strong>，是<strong>真正的流式计算</strong>，支持<strong>毫秒级</strong>计算</li>
<li>Flink 支持的窗口操作<strong>非常灵活</strong>，不仅支持<strong>时间窗口</strong>，还支持<strong>基于数据本身的窗口</strong></li>
</ul>
</li>
</ol>
<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><blockquote>
<p>Spark</p>
</blockquote>
<ol>
<li>Spark 和 Flink 分别提供 <strong>Spark SQL</strong> 和 <strong>Table API</strong> 提供 <strong>SQL</strong> 支持</li>
<li><strong>Spark 对 SQL 支持更好</strong>，相应的<strong>优化</strong>、<strong>扩展</strong>和<strong>性能</strong>更好</li>
</ol>
<h3 id="迭代计算"><a href="#迭代计算" class="headerlink" title="迭代计算"></a>迭代计算</h3><blockquote>
<p>Flink</p>
</blockquote>
<ol>
<li>Spark 对<strong>机器学习</strong>的支持很好，可以在<strong>内存</strong>中<strong>缓存中间计算结果</strong>来<strong>加速</strong>机器学习算法的运行</li>
<li>但大部分机器学习算法其实是个<strong>有环的数据流</strong>，在 <strong>Spark</strong> 中，却是用<strong>无环图</strong>来表示</li>
<li><strong>Flink</strong> 支持在运行时间中的<strong>有环数据流</strong>，从而可以更有效地对机器学习算法进行运算</li>
</ol>
<h3 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h3><blockquote>
<p>Spark</p>
</blockquote>
<ol>
<li>Spark 社区更活跃，各种扩展库也更全面</li>
</ol>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><ol>
<li><strong>数据量非常大</strong>而且<strong>逻辑复杂</strong>的<strong>批处理</strong>，并且对<strong>计算效率</strong>有较高要求</li>
<li>基于<strong>历史数据</strong>的<strong>交互式查询</strong>，要求<strong>响应较快</strong></li>
<li>基于<strong>实时数据流</strong>的数据处理，延迟性要求在<strong>百毫秒</strong>到<strong>数秒</strong>之间</li>
</ol>
<h3 id="Flink-1"><a href="#Flink-1" class="headerlink" title="Flink"></a>Flink</h3><ol>
<li>Flink 是为了<strong>提升流处理</strong>而创建的平台，适用于各种需要<strong>非常低延迟</strong>的<strong>实时数据处理</strong>场景 - 实时日志分析</li>
<li>Flink 是<strong>用流处理去模拟批处理</strong>的思想，比 Spark <strong>用批处理去模拟流处理</strong>的思想<strong>扩展性更好</strong></li>
</ol>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://blog.zhongmingmao.top">zhongmingmao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://blog.zhongmingmao.top/2024/09/22/bigdata-spark-flink/">https://blog.zhongmingmao.top/2024/09/22/bigdata-spark-flink/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/big-data/">Big Data</a><a class="post-meta__tags" href="/tags/spark/">Spark</a><a class="post-meta__tags" href="/tags/flink/">Flink</a></div><div class="post-share"><div class="social-share" data-image="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-flink.jpeg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/09/23/bigdata-beam-context/" title="Beam - Context"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-beam-context.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Beam - Context</div></div><div class="info-2"><div class="info-item-1">MapReduce架构思想 提供一套简洁的 API 来表达工程师数据处理的逻辑 在这套 API 底层嵌套一套扩展性很强的容错系统    计算模型 Map   计算模型从输入源中读取数据集合 这些数据经过用户所写的逻辑后生成一个临时的键值对数据集 MapReduce 计算模型会将拥有相同键的数据集集中起来发送到下一阶段，即 Shuffle 阶段   Reduce   接收从 Shuffle 阶段发送过来的数据集 在经过用户所写的逻辑后生成零个或多个结果  划时代意义 Map 和 Reduce 这两种抽象，其实可以适用于非常多的应用场景 MapReduce 的容错系统，可以让数据处理逻辑在分布式环境下有很好的扩展性（Scalability）  不足 使用 MapReduce 来解决一个工程问题，往往会涉及非常多的步骤 每次使用 MapReduce 时，都需要在分布式环境中启动机器来完成 Map 和 Reduce 步骤 并且需要启动 Master 机器来协调两个步骤的中间结果，存在不少的硬件资源开销  FlumeJava 将所有的数据都抽象成名为 PCollection 的数据结构 无论是从内存中读取的数据，...</div></div></div></a><a class="pagination-related" href="/2024/09/21/bigdata-spark-structured-streaming/" title="Spark - Structured Streaming"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-structured-streaming.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Spark - Structured Streaming</div></div><div class="info-2"><div class="info-item-1">背景 Spark Streaming 将无边界的流数据抽象成 DStream 按特定的时间间隔，把数据流分割成一个个 RDD 进行批处理 DStream API 与 RDD API 高度相似，拥有 RDD 的各种性质   DataSet&#x2F;DataFrame DataSet&#x2F;DataFrame 是高级 API，提供类似于 SQL 的查询接口，方便熟悉关系型数据库的开发人员使用 Spark SQL 执行引擎会自动优化 DataSet&#x2F;DataFrame 程序 用 RDD API 开发的程序本质上需要开发人员手工构造 RDD 的 DAG 执行图，依赖于手工优化     如果拥有 DataSet&#x2F;DataFrame API 的流处理模块 无需去用相对底层的 DStream API 去处理无边界数据，大大提升开发效率   在 2016 年，Spark 2.0 中推出结构化流处理的模块 - Structured Streaming Structured Streaming 基于 Spark SQL 引擎实现 在开发视角，流数据和静态数据没有区别，可以像批处理静态数据那样处理流...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/09/21/bigdata-spark-structured-streaming/" title="Spark - Structured Streaming"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-structured-streaming.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-21</div><div class="info-item-2">Spark - Structured Streaming</div></div><div class="info-2"><div class="info-item-1">背景 Spark Streaming 将无边界的流数据抽象成 DStream 按特定的时间间隔，把数据流分割成一个个 RDD 进行批处理 DStream API 与 RDD API 高度相似，拥有 RDD 的各种性质   DataSet&#x2F;DataFrame DataSet&#x2F;DataFrame 是高级 API，提供类似于 SQL 的查询接口，方便熟悉关系型数据库的开发人员使用 Spark SQL 执行引擎会自动优化 DataSet&#x2F;DataFrame 程序 用 RDD API 开发的程序本质上需要开发人员手工构造 RDD 的 DAG 执行图，依赖于手工优化     如果拥有 DataSet&#x2F;DataFrame API 的流处理模块 无需去用相对底层的 DStream API 去处理无边界数据，大大提升开发效率   在 2016 年，Spark 2.0 中推出结构化流处理的模块 - Structured Streaming Structured Streaming 基于 Spark SQL 引擎实现 在开发视角，流数据和静态数据没有区别，可以像批处理静态数据那样处理流...</div></div></div></a><a class="pagination-related" href="/2024/09/20/bigdata-spark-streaming/" title="Spark - Streaming"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-streaming.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-20</div><div class="info-item-2">Spark - Streaming</div></div><div class="info-2"><div class="info-item-1">流处理 Spark SQL 中的 DataFrame API 和 DataSet API 都是基于批处理模式对静态数据进行处理 在 2013，Spark 的流处理组件 Spark Streaming 发布，现在的 Spark Streaming 已经非常成熟，应用非常广泛    原理 Spark Streaming 的原理与微积分的思想很类似 微分是无限细分，而积分是对无限细分的每一段进行求和 本质 - 将一个连续的问题转换成了无限个离散的问题   流处理的数据是一系列连续不断变化，且无边界的，永远无法预测下一秒的数据 Spark Streaming 用时间片拆分了无限的数据流 然后对每个数据片用类似于批处理的方法进行处理，输出的数据也是分块的      Spark Streaming 提供一个对于流数据的抽象 DStream DStream 可以由 Kafka、Flume 或者 HDFS 的流数据生成，也可以由别的 DStream 经过各种转换操作得到 底层 DStream 由多个序列化的 RDD 构成，按时间片（如一秒）切分成的每个数据单位都是一个 RDD Spark 核心引擎将对 DStream ...</div></div></div></a><a class="pagination-related" href="/2024/09/19/bigdata-spark-sql/" title="Spark - SQL"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-sql.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-19</div><div class="info-item-2">Spark - SQL</div></div><div class="info-2"><div class="info-item-1">历史Hive 一开始，Hadoop&#x2F;MapReduce 在企业生产中大量使用，在 HDFS 上积累了大量数据 MapReduce 对于开发者而言使用难度较大，大部分开发人员最熟悉的还是传统的关系型数据库 为了方便大多数开发人员使用 Hadoop，诞生了 Hive Hive 提供类似 SQL 的编程接口，HQL 经过语法解析、逻辑计划、物理计划转化成 MapReduce 程序执行 使得开发人员很容易对 HDFS 上存储的数据进行查询和分析      Shark 在 Spark 刚问世时，Spark 团队开发了 Shark 来支持用 SQL 来查询 Spark 的数据 Shark 的本质是 Hive，Shark 修改了 Hive 的内存管理模块，大幅优化了运行速度 Shark 依赖于 Hive，严重影响了 Spark 的发展，Spark 要定义一个统一的技术栈和完整的生态 依赖于 Hive 还会制约 Spark 各个组件的相互集成，Spark 无法利用 Spark 的特性进行深度优化 2014 年 7 月 1 日，Spark 团队将 Shark 交给 Hive 进行管理，即 Hive on Spa...</div></div></div></a><a class="pagination-related" href="/2024/09/18/bigdata-spark-rdd/" title="Spark - RDD"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark-rdd.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-18</div><div class="info-item-2">Spark - RDD</div></div><div class="info-2"><div class="info-item-1">分布式内存 传统的 MapReduce 框架运行缓慢，主要原因是 DAG 的中间计算结果需要写入硬盘来防止运行结果丢失 每次调用中间计算结果都需要进行一次硬盘的读取 反复对硬盘进行读写操作以及潜在的数据复制和序列化操作会大大地提高了计算延迟   新的分布式存储方案 - 保持之前系统的稳定性、错误恢复和可扩展性，并尽可能地减少硬盘 IO 操作 RDD 是基于分布式内存的数据抽象，不仅支持基于工作集的应用，同时具有数据流模型的特点      定义分区 分区代表同一个 RDD 包含的数据被存储在系统的不同节点上，这是可以被并行处理的前提 在逻辑上，可以认为 RDD 是一个大数组，数组中的每个元素代表一个分区（Partition） 在物理存储中，每个分区指向一个存放在内存或者硬盘中的数据块（Block） Block 是独立的，可以被存放在分布式系统中的不同节点   RDD 只是抽象意义的数据集合，分区内部并不会存储具体的数据    RDD 中的每个分区都有它在该 RDD 中的 Index 通过 RDD_ID 和 Partition_Index 可以唯一确定对应 Block 的编号 从而通过底层存储层的接口中提取...</div></div></div></a><a class="pagination-related" href="/2024/09/17/bigdata-spark-overview/" title="Spark - Overview"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/bigdata-spark.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-17</div><div class="info-item-2">Spark - Overview</div></div><div class="info-2"><div class="info-item-1">MapReduce概述 MapReduce 通过简单的 Map 和 Reduce 的抽象提供了一个编程模型 可以在一个由上百台机器组成的集群上并发处理大量的数据集，而把计算细节隐藏起来   各种各样的复杂数据处理都可以分解为 Map 和 Reduce 的基本元素 复杂的数据处理可以分解成由多个 Job（包含一个 Mapper 和一个 Reducer）组成的 DAG 然后，将每个 Mapper 和 Reducer 放到 Hadoop 集群上执行，得到最终结果      不足 高昂的维护成本 时间性能不达标 MapReduce 模型的抽象层次低 大量的底层逻辑需要开发者手工完成 - 用汇编语言开发游戏   只提供 Map 和 Reduce 操作 很多现实的数据处理场景并不适合用这个模型来描述 实现复杂的操作需要技巧，让整个工程变得庞大且难以维护 维护一个多任务协调的状态机成本很高，且扩展性很差   在 Hadoop 中，每个 Job 的计算结果都会存储在 HDFS 文件存储系统中 每一步计算都要进行硬盘的读取和写入，大大增加了系统的延迟   MapReduce 对于迭代算法的处理性能很差，而且非常耗资源 因...</div></div></div></a><a class="pagination-related" href="/2024/10/05/bigdata-beam-future/" title="Beam - Future"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://big-data-1253868755.cos.ap-guangzhou.myqcloud.com/flink-runner-beam-beam-vision.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-05</div><div class="info-item-2">Beam - Future</div></div><div class="info-2"><div class="info-item-1">技术迭代 2006，Apache Hadoop 发布，基于 MapReduce 计算模型 2009，Spark 计算框架在 加州伯克利大学诞生，于 2010 年开源，于 2014 年成为 Apache 的顶级项目 Spark 的数据处理效率远在 Hadoop 之上   2014，Flink 面世，流批一体，于 2018 年被阿里收购    Apache Beam Apache Beam 根据 Dataflow Model API 实现的，能完全胜任批流一体的任务 Apache Beam 有中间的抽象转换层，工程师无需学习新 Runner 的 API 的语法，减少学习新技术的时间成本 Runner 可以专心优化效率和迭代功能，而不必担心迁移  Beam Runner 迭代非常快 - 如 Flink  </div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/z.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">zhongmingmao</div><div class="author-info-description">Focus on Infrastructure.</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">639</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">83</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="mailto:zhongmingmao0625@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Things are always unexpected!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spark-%E5%AE%9E%E6%97%B6%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">Spark 实时性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Flink"><span class="toc-number">2.</span> <span class="toc-text">Flink</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Flink-vs-Spark"><span class="toc-number">3.</span> <span class="toc-text">Flink vs Spark</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-number">3.1.</span> <span class="toc-text">相同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%BC%82%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">差异点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E5%A4%84%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">流处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL"><span class="toc-number">3.2.2.</span> <span class="toc-text">SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E8%AE%A1%E7%AE%97"><span class="toc-number">3.2.3.</span> <span class="toc-text">迭代计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%80%81"><span class="toc-number">3.2.4.</span> <span class="toc-text">生态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">3.3.</span> <span class="toc-text">场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spark"><span class="toc-number">3.3.1.</span> <span class="toc-text">Spark</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">Flink</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/21/cloud-native-observability-opentelemetry-java-zero-code/" title="Observability - OpenTelemetry Java Zero Code"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://observability-1253868755.cos.ap-guangzhou.myqcloud.com/otel-java-agent.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Observability - OpenTelemetry Java Zero Code"/></a><div class="content"><a class="title" href="/2025/01/21/cloud-native-observability-opentelemetry-java-zero-code/" title="Observability - OpenTelemetry Java Zero Code">Observability - OpenTelemetry Java Zero Code</a><time datetime="2025-01-20T16:06:25.000Z" title="Created 2025-01-21 00:06:25">2025-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/20/cloud-native-observability-opentelemetry-java/" title="Observability - OpenTelemetry Java"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://observability-1253868755.cos.ap-guangzhou.myqcloud.com/otel-java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Observability - OpenTelemetry Java"/></a><div class="content"><a class="title" href="/2025/01/20/cloud-native-observability-opentelemetry-java/" title="Observability - OpenTelemetry Java">Observability - OpenTelemetry Java</a><time datetime="2025-01-19T16:06:25.000Z" title="Created 2025-01-20 00:06:25">2025-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/19/ai-agent-overview-mcp/" title="AI Agent - MCP Overview"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ai-agent-1253868755.cos.ap-guangzhou.myqcloud.com/mcp.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI Agent - MCP Overview"/></a><div class="content"><a class="title" href="/2025/01/19/ai-agent-overview-mcp/" title="AI Agent - MCP Overview">AI Agent - MCP Overview</a><time datetime="2025-01-18T16:06:25.000Z" title="Created 2025-01-19 00:06:25">2025-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/18/ai-agent-overview/" title="AI Agent - Overview"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ai-agent-1253868755.cos.ap-guangzhou.myqcloud.com/ai-agent.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI Agent - Overview"/></a><div class="content"><a class="title" href="/2025/01/18/ai-agent-overview/" title="AI Agent - Overview">AI Agent - Overview</a><time datetime="2025-01-17T16:06:25.000Z" title="Created 2025-01-18 00:06:25">2025-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/17/new-java-feature-foreign-function-api/" title="New Java Feature - Foreign Function API"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://java-feature-1253868755.cos.ap-guangzhou.myqcloud.com/Java-Foreign-Function-API.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="New Java Feature - Foreign Function API"/></a><div class="content"><a class="title" href="/2025/01/17/new-java-feature-foreign-function-api/" title="New Java Feature - Foreign Function API">New Java Feature - Foreign Function API</a><time datetime="2025-01-16T16:06:25.000Z" title="Created 2025-01-17 00:06:25">2025-01-17</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2015 - 2025 By zhongmingmao</span></div><div class="footer_custom_text">Life is like a box of chocolates. You can't know what you'll eat until you open it.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div></body></html>