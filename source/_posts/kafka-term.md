---
title: Kafka -- 术语
mathjax: false
date: 2019-06-22 19:35:39
categories:
    - Middleware
    - MQ
    - Kafka
tags:
    - Middleware
    - MQ
    - Kafka
    - Stream
---

## 主题 + 客户端
1. 发布订阅的对象是**主题**（Topic）
2. 向主题发布消息的客户端应用程序称为**生产者**（Producer），生产者可以持续不断地向**多个主题**发送消息
3. 订阅这些主题消息的客户端应用程序称为**消费者**（Consumer），消费者能够同时订阅**多个主题**的消息
4. 生产者和消费者统称为**客户端**

<!-- more -->

## 服务端
1. Kafka的服务端由被称为**Broker**的**服务进程**构成，一个Kafka集群由多个Broker组成
2. Broker负责**接收和处理**客户端发送过来的请求，以及对消息进行**持久化**
3. 多个Broker进程能够运行在同一台机器上，但更常见的做法是将不同的Broker**分散运行在不同的机器**上
    - 这样如果集群中某一台机器宕机了，即使在它上面运行的所有Broker进程都挂掉了
    - 其他机器上的Broker也依然能够对外提供服务，这是Kafka提供**高可用**的手段之一

## 备份
1. 实现**高可用**的另一个手段是**备份机制**（Replication）
2. 备份：把**相同的数据**拷贝到多台机器上，这些相同的数据拷贝在Kafka中被称为**副本**（Replica）
3. 副本的数量是可以配置的，Kafka定义了两类副本：**领导者副本**（Leader Replica）和**追随者副本**（Follower Replica）
    - 领导者副本：**对外提供服务**，对外指的是与客户端程序进行交互
        - 生产者总是向领导者副本写消息
        - 消费者总是从领导者副本读消息
    - 追随者副本：**被动地追随领导者副本**，不能与外界交互
        - 向领导者副本发送请求，请求领导者副本把最新生产的消息发给它，进而与领导者副本保持同步
        - MySQL的从库是可以处理读请求的
    - Master-Slave => Leader-Follower
4. 副本机制可以保证**数据的持久化**或者**消息不丢失**，但没有解决**伸缩性**（Scalability）的问题
    - 如果领导者副本积累了太多的数据以至于单台Broker机器无法容纳，该如何处理？
    - 可以把数据分割成多份，然后保存在不同的Broker上，这种机制就是**分区**（Partitioning）
        - MongoDB、Elasticsearch -- Sharding
        - HBase -- Region

## 分区
1. Kafka中的分区机制是将每个**主题**划分成多个**分区**（Partition），每个分区是_**一组有序的消息日志**_
2. 生产者生产的每条消息只会被发送到一个分区中，Kafka的分区编号是从0开始的
3. 副本是在分区这个层级定义的，每个分区下可以配置N个副本，只能有1个领导者副本和N-1个追随者副本
4. 生产者向分区（**分区的领导者副本**）写入消息，每条消息在分区中的位置由**位移**（Offset）来表征，而**分区位移**总是从0开始
5. 三层消息架构
    - 第一层是**主题**层，每个主题可以配置M个分区，而每个分区又可以配置N个副本
    - 第二层是**分区**层
        - 每个分区的N个副本中只能有1个领导者副本，**对外提供服务**
        - 其他N-1个副本是追随者副本，只能提供**数据冗余**
    - 第三层是**消息**层，分区中包含若干条消息，每条消息的位移从0开始，依次递增
    - 最后，客户端程序只能与**分区的领导者副本**进行交互

## 持久化
1. Kafka使用消息**日志**（Log）来保存数据，一个日志是磁盘上一个**只能追加写**（Append-Only）消息的物理文件
    - 只能追加写入，避免了缓慢的随机IO操作，改为性能较好的**顺序IO操作**，这是实现Kafka**高吞吐量**的一个重要手段
2. Kafka需要**定期删除消息**以回收磁盘空间，可以通过**日志片段**（Log Segment）机制来实现
    - 在Kafka底层，一个日志又被细分成多个日志段，消息被追加到**当前最新的日志段**中
    - 当写满一个日志段后，Kafka会自动切分出一个新的日志段，并将老的日志段封存起来
    - Kafka在后台有定时任务定期地检查这些老的日志段是否能够被删除，从而实现回收磁盘空间的目的

## 消费者
1. 点对点模型（Peer to Peer，P2P）：**同一条消息只能被下游的一个消费者消费**，其他消费者不能染指
2. Kafka通过**消费者组**（Consumer Group）来实现**P2P模型**
    - 消费者组：多个消费者实例共同组成一个组来消费一组主题
    - 这组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费它
        - 即**消费者对分区有所有权**
3. 引入消费者组的目的：**提高消费者端的吞吐量**（TPS）
4. 消费者实例（Consumer Instance）：即可以是运行消费者应用的**进程**，也可以是一个**线程**
5. **重平衡**（Rebalance）
    - 若组内的某个实例挂了，Kafka能够自动检测到，然后把这个挂掉的实例之前负责的分区转移给组内其他存活的消费者
    - 重平衡引发的消费者问题很多，目前很多重平衡的Bug社区都无力解决
6. **消费者位移**（Consumer Offset）：记录消费者当前消费到了分区的哪个位置，**随时变化**
    - 分区位移：表征的是消息在分区内的位置，一旦消息被成功写入到一个分区上，消息的分区位移就**固定**了

## 小结
<img src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/geek-time/kafka-term.png" width=1000/>

1. 消息（Record）：消息是Kafka处理的主要对象
2. 主题（Topic）：主题是承载消息的**逻辑容器**，实际使用中多用来区分具体的业务
3. 分区（Partition）：一个**有序不变的消息序列**，每个主题下有多个分区
4. 消息位移（Offset）：也叫分区位移，表示一条消息在分区中的位置，是一个**单调递增且不变**的值
5. 副本（Replica）
    - Kafka中同一条消息能够被拷贝到多个地方以提供**数据冗余**
    - 副本分为领导者副本和追随者副本，副本在分区的层级下，每个分区可配置多个副本实现**高可用**
6. 生产者（Producer）：向主题发布消息的应用程序
7. 消费者（Consumer）：从主题订阅消息的应用程序
8. 消费者位移（Consumer Offset）：表征消费者的**消费进度**，每个消费者都有自己的消费者位移
9. 消费者组（Consumer Group）：多个消费者实例共同组成一个组，同时消费多个分区以实现**高吞吐**
10. 重平衡（Rebalance）
    - 消费者组内某个消费者实例挂掉后，其他消费者实例自动**重新分配订阅分区**的过程
    - 重平衡是Kafka**消费者端**实现**高可用**的重要手段

## 参考资料
[Kafka核心技术与实战](https://time.geekbang.org/column/intro/100029201)