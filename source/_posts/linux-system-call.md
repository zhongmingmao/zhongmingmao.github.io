---
title: Linux -- 系统调用
date: 2019-04-07 23:22:46
categories:
    - Linux
tags:
    - Linux
---

## 进程管理
1. 在Linux里，创建一个新进程，需要老进程调用`fork`来实现
2. 老进程叫作**父进程**（`Parent Process`），新进程叫作**子进程**（`Child Process`）
3. 当父进程调用`fork`创建进程的时候，子进程将**各个子系统**为父进程创建的数据结构也**全部**拷贝一份（包括程序代码）
    - 如果不进行特殊处理，父进程和子进程都按相同的代码逻辑进行下去
4. `fork`系统调用的返回值
    - 如果**当前进程**是**子进程**，就返回**0**
    - 如果**当前进程**是**父进程**，返回_**子进程的进程号**_
5. 依据`fork`的返回值执行不同的逻辑分支
    - 如果是**父进程**，执行原始逻辑
    - 如果是**子进程**，请求系统调用`execve`来执行另一个程序
        - 至此，子进程和父进程就彻底**分道扬镳**了，产生了一个fork（分支）
6. 操作系统在**启动**时会先创建**所有用户进程**的_**祖宗进程**_
7. 父进程如果需要知道子进程的运行情况，
    - 父进程可以请求系统调用`waitpid`，将**子进程的进程号**作为参数传给它
    - 这样父进程就知道子进程是否运行成功

<!-- more -->

## 内存管理
1. 在操作系统中，每个进程都有自己的内存，**互不干扰**，有_**独立的进程内存空间**_
2. **代码段**（`Code Segment`）：存放_**程序代码**_
3. **数据段**（`Data Segment`）：存放_**进程在运行过程中产生的数据**_
    - 其中**局部变量**的部分，在当前函数执行的时候才起作用，当进入另一个函数时，局部变量就会被释放
    - 也有**动态分配**的，会**较长时间保存**，指明才销毁的，这部分称为**堆**（`Heap`）
4. 一个进程的内存空间是很大的，32位的是4G，但不可能有那么多的物理内存，到**真正需要**的时候再分配
    - 进程自己不用的部分就不用管了，只有进程去使用部分内存的时候，才会使用**内存管理的系统调用**来登记
    - 但这不代表真的就对应到了物理内存，只有在**真的写入数据**的时候，发现没有对应的物理内存
        - 才会触发一个**中断**，_**现分配物理内存**_
5. 在**堆里**分配内存的系统调用：`brk`和`mmap`
    - 当分配的内存数量**比较小**的时候，使用`brk`，会**和原来的堆的数据连在一起**
        - brk, sbrk - _**change data segment size**_
    - 当分配到内存数量**比较大**的时候，使用`mmap`，会**重新划分一块区域**
        - mmap, munmap - _**map or unmap files or devices into memory**_

## 文件管理
1. 系统调用
    - 对于已经存在的文件，使用`open`打开这个文件，使用`close`关闭这个文件
    - 对于不存在的文件，使用`create`创建文件
    - 打开文件以后，使用`lseek`跳到文件的某个位置
    - 可以对文件的内容进行读写，读的系统调用是`read`，写的系统调用是`write`
2. _**一切皆文件**_
    - 启动一个进程，需要一个程序文件，这是一个**二进制文件**
    - 启动的时候，需要加载一些配置文件，例如yml、properties等，这是**文本文件**
        - 启动之后会打印一些日志，如果写到硬盘上，也是**文本文件**
        - 如果把日志打印到交互控制台上，也是一个文件，是**stdout文件**
    - 这个进程的输出可以作为另一个进程的输入，这种方式称为**管道**，**管道也是一个文件**
    - 进程之间可以通过网络进行进行通信，建立`Socket`，**`Socket`也是一个文件**
    - 进程需要访问外部设备，**设备也是一个文件**
    - 文件都被存储在文件夹里面，**文件夹也是一个文件**
    - 进程运行起来，进程X的运行情况会在`/proc/${X}`目录体现出来，该目录下也是一系列的文件
3. Linux会为**每个文件**分配一个**文件描述符**（`File Descriptor`，是一个**整数**）
4. 文件操作是贯穿始终的，一切皆文件的优势：_**统一了操作的入口**_

## 信号处理
1. 常见信号
    - 在执行一个程序的时候，在键盘上输入`CTRL+C`，这是**中断信号**，正在执行的命令就会中止退出
    - 非法访问内存
    - 硬件故障，设备出现了问题
    - 用户进程通过`kill`函数，将一个用户信号发送给另一个进程
2. 对于一些不严重的信号，可以忽略，但类似`SIGKILL`和`SIGSTOP`是不能忽略的，可以执行**信号的默认动作**
    - 每种信号都定义了默认的动作，例如硬件故障，默认终止
    - 也可以提供**信号处理函数**，通过请求系统调用`sigaction`，注册一个信号处理函数
        - sigaction, rt_sigaction - _**examine and change a signal action**_

## 进程间通信
1. **消息队列**（`Message Queue`）
    - 两个进程间交互的信息**较小**，这个消息队列在**内核**里
    - `msgget`：创建一个新队列，_**get a System V message queue identifier**_
    - `msgsnd`：将消息发送到消息队列，_**XSI message send operation**_
    - `msgrcv`：消息接收方从队列中取数据，_**XSI message receive operation**_
2. **共享内存**
    - 两个进程间交互的信息**较大**
    - `shmget`：创建一个共享内存块
        - shmget - _**allocates a System V shared memory segment**_
    - `shmat`：将共享内存**映射**到自己的进程内存空间，然后就可以进行**读写**了
        - shmat — _**XSI shared memory attach operation**_
    - 存在**竞争**问题，解决方案：_**信号量机制**_（`Semaphore`）
        - 对于只允许一个进程访问的资源，可以将信号量设为1
        - 当进程A要访问的时候，会先请求系统调用`sem_wait`，如果此时没有其他进程访问，则**占用**这个信号量
        - 如果此时进程B要访问，也会调用`sem_wait`，进程B必须等待
        - 当进程A访问完毕，会调用`sem_post`将信号量**释放**，进程B就可以访问这个资源了

## 网络通信
1. 不同机器通过网络相互通信，需要遵循相同的网络协议，即**TCP/IP网络协议栈**，Linux内核有对网络协议栈的实现
2. 网络服务是通过套接字`Socket`来提供服务的，可以通过`Socket`系统调用来创建一个`Socket`
3. `Socket`是一个**文件**，也有一个**文件描述符**，也可以通过**读写函数**进行通信

## 系统调用定义
路径：`linux-5.0.7/arch/sh/include/uapi/asm/unistd_64.h`
```
#define __NR_restart_syscall      0
#define __NR_exit                 1
#define __NR_fork                 2
#define __NR_read                 3
#define __NR_write                4
#define __NR_open                 5
#define __NR_close                6
#define __NR_waitpid              7
#define __NR_creat                8
...
```

## glibc
1. `glibc`是Linux下开源的标准C库，由`GNU`发布
2. `glibc`提供了丰富的API
    - 封装了例如字符串处理、数学运算等**用户态服务**
    - 封装了操作系统提供的系统服务，即_**系统调用的封装**_
3. 每个系统调用都对应至少一个`glibc`封装的库函数
    - 打开文件系统调用，操作系统->`sys_open`，`glibc`->`open`
4. `glibc`中一个单独的API可能会调用多个系统调用
    - `glibc`提供的`printf`函数就会调用如`sys_open`、`sys_mmap`、`sys_write`和`sys_close`等系统调用
5. 多个`glibc API`也可能只对应一个系统调用
    - `glibc`的`malloc`、`calloc`和`free`等函数用来分配和释放内存，都调用了内核的`sys_brk`的系统调用

## 小结
<img src="https://linux-1253868755.cos.ap-guangzhou.myqcloud.com/linux-system-call.jpg"/>

<!-- indicate-the-source -->
