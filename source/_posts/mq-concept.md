---
title: MQ - Concept
mathjax: true
date: 2024-10-07 00:06:25
cover: https://mq-1253868755.cos.ap-guangzhou.myqcloud.com/mq-concept.jpg
categories:
  - MQ
tags:
  - MQ
---

# 消息管道

> 在系统架构中，MQ 的定位是**消息**和**管道**，主要起到**解耦上下游系统**，**数据缓存**的作用，主要操作为**生产**和**消息**

![2cb1c8245c15f3df28228af3c8b8bd8c](https://mq-1253868755.cos.ap-guangzhou.myqcloud.com/2cb1c8245c15f3df28228af3c8b8bd8c.jpg)

<!-- more -->

# 架构

![845c85d7f3d55cd47c894f0b8eb7ab06](https://mq-1253868755.cos.ap-guangzhou.myqcloud.com/845c85d7f3d55cd47c894f0b8eb7ab06.jpg)

## Broker

1. Broker 本质上是一个**进程**
2. 在实际部署过程中，通常**一个物理节点**只会起**一个进程**，在大部分情况下，**Broker** 表示**一个节点**

## Topic

1. 在大部分 MQ 中，Topic 都是用来**组织分区关系**的一个**逻辑概念**
2. 通常情况下，**一个 Topic** 会包含**多个分区**
   - 在 **RabbitMQ** 中，Topic 是指具体的一种**主题模式**

## Partition

> Queue / MessageQueue

1. 在 MQ 中，分区、分片、**Partition**、Queue、MessageQueue 是一个概念，用来表示**数据存储**的**最小单位**
2. 可以将**消息**写入到一个**分区**中，也可以将**消息**写入到 **Topic** 中，再**分发**到具体的某个分区
3. **一个 Topic** 通常会包含**一个或多个分区**

## Producer

1. 消息的发送方，即发送消息的客户端

## Consumer

1. 消息的接收方，即接收消息的客户端

## ConsumerGroup

> Subscription

1. 一般情况下，MQ 中的 ConsumerGroup 和 Subscription 是同一概念
2. 用来组织**消费者**和**分区关系**的**逻辑概念**，也可用于保存**消费进度**

## Message

1. 一条真实的**业务数据**，MQ 中的每条数据一般都叫做一条**消息**

## Offset

> ConsumerOffset / Cursor

1. 指消费者**消费分区**的**进度**
2. 每个消费者都会去消费分区，为了避免**重复消费**，都会保存消费者消费分区的进度信息

## ACK

> OffsetCommit

1. **提交消费进度**的操作，即数据**消费成功**后，提交当前的**消费位点**，确保**不重复消费**

## Leader + Follower

1. Leader 和 Follower 一般是**分区维度副本**的概念
2. **一个分区**一般会有**多个副本**，副本有**主从**概念，一般是**一个主副本**和**多个从副本**

## Segment

1. 指消息数据在**底层具体存储**时，分为**多个文件**存储时的文件，该文件叫做分区的**数据段**
2. 如每超过 1G 的文件就新起一个文件来存储，即 Segment
3. 几乎所有的 MQ 都有 Segment 的概念，如 Kafka 的 Segment，**Pulsar** 的 **Ledger**

## StartOffset + EndOffset

1. StartOffset 和 EndOffset 是**分区维度**的概念
2. 数据是**顺序写入**分区的，一般从 0 位置开始往后写，此时 StartOffset 为 0
3. 数据会**过期**，分区维度较早的数据会被清理，此时 StartOffset 会往后移，表示当前**最早的有效数据的位点**
4. EndOffset 即**最新**的那条数据的写入位点
5. StartOffset 和 EndOffset 是一直**动态变化**的

## ACL

1. 用来对集群中的**资源**进行**权限控制**，如控制 Topic 或 Partition 的读写操作等

# 功能

## 顺序消息

1. Consumer **按 Producer 写入的顺序**来消费消息

## 延时消息

> 定时消息

1. Producer 发送消息到 Broker 时，设置该**消息在多久后会被消费到**，当时间到了，消息会被消费到
2. 延时以 **Broker 收到消息的时间**为准，多久后消息能被 Consumer 消费
3. 定时是指消息在**设置的时间**才能被看到
4. 在技术上，延时和定时是一样的

## 事务消息

1. 不同的 MQ 关于事务的定义，也是不太一样的
2. 正常情况下，事务表示**多个操作的原子性**
   - 在 MQ 中，一般指的是**发送一批消息**，要么**同时成功**，要么**同时失败**

## 消息重试

1. Producer 重试 - 当消息发送失败后，可以设置重试策略
2. Consumer 重试 - 当消费的消息处理失败后，会自动重试消费消息

## 消息回溯

1. 消息可以被**多次消费**
2. 某条消息消费成功后，该消息不会被删除，后续还能再重复消费到该消息

## 广播消费

1. **一条消息**可以被**多个消费者**消费

## 死信队列

1. 当某条消息**无法成功处理**时，把该消息写入到一个**死信队列**中，继续处理后续消息
2. 大部分情况下，**死信队列**在 **Consumer** 中使用

## 优先级队列

1. 给 **Partition** 中**消息**设置**权重**，权重大的消息能够被优先消费到
2. 大部分情况下，MQ 的消息处理是 **FIFO** 的规则
3. **优先级**是在**消息维度**设置的

## 消息过滤

1. 给每条消息打上 **Tag**，在**消费**的时候根据 Tag 去消费消息
2. 通过 Tag 去查询**过滤**消息 - 在 **Consumer** 端

## TTL

1. MQ 中的消息会在一定**时间**或者超过一定**大小**后会被删除
2. MQ 的主要是**缓冲**作用，一般会要求消息在一定的策略后自动被**清理**

## 消息轨迹

1. 记录一条消息从 **Producer 发送**、**Broker 保存**、**Consumer 消费**的**全生命周期**的流程信息

## 消息查询

1. 根据某些信息查询到消息队列中的信息
2. 根据**消息 ID** 或者**消费位点**来查询消息 - SQL Select

## 消息压缩

1. Producer **发送消息**的时候，是否支持将消息进行**压缩**，以节省物理资源
2. 压缩可以在 **Producer** 完成，也可以在 **Broker** 完成，一般会在 Producer 完成

## 多租户

1. **同一个集群**存在**逻辑隔离**
2. Namespace / Tenant

## 消息持久化

1. 消息被发送到 Broker 后，会不会**持久化存储**
2. 有些 MQ 为了保证**性能**，只会把消息存储在**内存**中，在节点重启后，数据会**丢失**

## 消息流控

1. 对**读写**集群的**消息**进行限制
2. 限流维度 - Topic / Partition / ConsumerGroup 等

# 选型

> 业务消息 - RocketMQ
> 流消息 - Kafka

## RabbitMQ + RocketMQ

> 业务消息 - 及时性、更多的功能特性、消息可追踪

1. RabbitMQ 和 RocketMQ 属于**业务消息**类的 MQ
2. RabbitMQ 发展较早，**RocketMQ** 是新生的消息类的消息队列
3. 从**功能**、**集群化**、**稳定性**、**性能**来看，**RocketMQ** 都优于 RabbitMQ - **RocketMQ 替代 RabbitMQ**
4. 国内 - RocketMQ；国外 - RabbitMQ

## Kafka

> 流消息 - 大流量、高吞吐

1. Kafka 属于**流**场景的 MQ - **高吞吐**、**大流量**
2. 功能简单 - 不支持死信队列、延时消息等功能
3. 非常**稳定** + **吞吐性能**非常高，能承担**超大流量**的业务场景 - 流场景下的消息管道的不二之选

## Pulsar

1. Pulsar 定位 - **消息**和**流**融合
2. 目标 - 满足所有**消息**和**流**的场景，同时满足**功能**和**性能**两方面的需求
3. 发展时间较短，不太稳定，处于快速发展阶段

