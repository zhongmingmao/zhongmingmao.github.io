---
title: Java性能 -- GC
mathjax: false
date: 2019-09-11 17:31:47
categories:
    - Java
    - Performance
tags:
    - Java
    - Java Performance
    - JVM
    - GC
---

## GC机制

### 回收区域
1. JVM的内存区域中，**程序计数器**、**虚拟机栈**、**本地方法栈**是**线程私有**，随线程的创建而创建，销毁而销毁
    - 栈中的栈帧随着方法的进入和退出进行**入栈**和**出栈**操作，每个栈帧分配多少内存基本是在**类结构**确定下来时就已知
    - 因此，这三个区域的内存**分配**和**回收**都是具有**确定性**的
2. **堆**中的回收主要是**对象**回收，**方法区**的回收主要是**废弃常量**和**无用类**的回收

<!-- more -->

### 回收时机
1. 当一个对象**不再被引用**，就代表该对象**可以被回收**
2. **引用计数法**：实现简单，判断效率高，但存在**循环引用**的问题
3. **可达性分析算法**：HotSpot VM

| 引用类型 | 功能特点 |
| --- | --- |
| **强引用**（Strong Reference） | 被强引用关联的对象，**永远**不会被垃圾回收器回收 |
| **软引用**（Soft Reference） | 被软引用关联的对象，只有当系统将要发生**内存溢出**时，才会去回收软引用关联的对象 |
| **弱引用**（Weak Reference） | **只**被弱引用关联的对象，**只要发生GC事件**，就会被回收 |
| **虚引用**（Phantom Reference） | 被虚引用关联的对象，**唯一作用**是在这个对象被回收时收到一个**系统通知** |

### 回收特性
1. **自动性**
    - Java提供了一个**系统级**的线程来**跟踪**每一块分配出去的内存空间
    - 当JVM处于**空闲循环**时，GC线程会自动检查每一块分配出去的内存空间，然后自动回收每一块空闲的内存块
1. **不可预期性**
    - 很难确定一个没有被引用的对象是否会被立即回收，有可能当程序结束时，该对象仍在内存中
    - GC线程在JVM中是**自动执行**的，**Java程序无法强制执行**，`System.gc`也只是**建议**执行垃圾回收

## GC算法
JVM提供了不同的GC算法来实现上面的GC机制

| GC算法类型 | 优点 | 缺点 |
| --- | --- | --- |
| **Mark-Sweep** | 不需要移动对象，简单高效 | **效率低**、产生**内存碎片** |
| **Copying** | 简单高效，不会产生内存碎片 | **内存使用率低**，有可能**频繁复制** |
| **Mark-Compact** | 综合了前两种算法的优点 | 仍需要**移动局部对象** |

## GC分类
1. 不管是什么GC，**都会有STW**，只有**时间长短**的区别（CMS和G1的STW会短很多）
2. 不用纠结于细分`Major GC`和`Full GC`，一次Full GC将对**新生代**、老年代、**元空间**、**堆外内存**进行垃圾回收
3. 触发Full GC的原因
    - 当新生代**晋升**到老年代的对象大小，比目前**老年代剩余的空间**还大
    - 当**老年代的空间使用率**超过某个**阈值**
    - 当**元空间**不足时（JDK 7**永久代**不足）
    - 调用`System.gc()`

## 垃圾回收器

### 分类
<img src="https://java-performance-1253868755.cos.ap-guangzhou.myqcloud.com/java-performance-gc-1.png" width=1000>

### 组合
<img src="https://java-performance-1253868755.cos.ap-guangzhou.myqcloud.com/java-performance-gc-2.jpg" width=800>

### CMS / G1

#### CMS
1. CMS是基于**标记清除**算法实现的，用于**老年代**GC
2. CMS的GC周期主要由**7个阶段**组成，其中两个阶段会发生**STW**，其它阶段都是**并发执行**的

| 阶段 | 描述 |
| --- | --- |
| **Initial Mark** | **STW**，**并行**标记**可直达的存活对象** |
| Concurrent Mark | 1. **并发执行**<br/>2. 继续**递归**遍历**老年代**，并标记可**直接**或**间接**到达的所有老年代存活对象<br/>3. 由于并发执行，对象可能发生**变化**，变化的对象所在的**Card**标识为**Dirty** |
| Concurrent Preclean | 重新扫描前一阶段标记的Dirty对象，并标记被Dirty对象直接或间接引用的对象，然后清除Card标识 |
| Concurrent Abortable Preclean | 标记可达的老年代对象，扫描处理**Dirty Card**中的对象 |
| **Fianl Remark** | **STW**，重新扫描之前**并发**处理阶段的所有**残留**更新对象 |
| Concurrent Sweep | 清理所有**未被标记**的**死亡**对象，回收被占用的空间 |
| Concurrent Reset | 清理并恢复在CMS GC过程中的各种状态，重新初始化CMS相关数据结构 |

#### G1
1. G1是基于**标记整理**算法实现的，是一个**分代**垃圾收集器，既负责**新生代**的GC，也负责**老年代**的GC
2. G1之前的各个分代使用的是**连续的虚拟内存地址**，G1使用了**Region**的方式对**堆内存**进行划分
    - 同样也分**新生代**和**老年代**，每一代使用的是N个**不连续**的Region内存块，每个Region占用一块**连续**的虚拟内存地址
    - G1中还有一种称为**Humongous**区域，用于存储**特别大**的对象
        - G1优化：一旦发现没有引用指向**巨型对象**，则可直接在**新生代的Young GC**中被回收掉
3. G1分为**Young GC**、**Mix GC**和**Full GC**
    - Young GC主要是在**Eden**区进行，当Eden区空间不足时，会触发一次Young GC
        - 将Eden区数据转移到Surivivor，如果Surivivor空间不足，（包括Surivivor的数据）则会**直接晋升**到老年代
        - Young GC是**并行**执行的，也会发生**STW**
    - 当堆空间的**占用率**达到一定阈值后会触发**G1 Mix GC**（参数`-XX:InitiatingHeapOccupancyPercent`，默认**45**）
        - Mix GC主要包括4个阶段，其中只有**并发标记**阶段不会发生STW，其它阶段均会发生STW

<img src="https://java-performance-1253868755.cos.ap-guangzhou.myqcloud.com/java-performance-gc-g1-heap.jpg" width=800/>
<img src="https://java-performance-1253868755.cos.ap-guangzhou.myqcloud.com/java-performance-gc-g1-young-mix.jpg" width=1000/>

#### 对比
1. **CMS**主要集中在**老年代**的回收，而**G1**集中在**分代**回收，包括**新生代的Young GC**和**老年代的Mix GC**
2. G1使用了**Region**的方式对堆内存进行划分，基于**标记整理**算法实现，整体减少了垃圾碎片的产生
3. 在**初始化标记**阶段，**搜索可达对象**时使用到了**Card Table**，但实现方式不一样
    - 在GC时，都是从**GC Root**开始搜索，有可能新生代引用到老年代对象，也有可能老年代引用到新生代对象
    - 如果发生**Young GC**，除了**从新生代扫描根对象**，还需要**从老年代扫描根对象**，确认引用新生代对象的情况
        - 这属于**跨代处理**，非常**消耗性能**
        - 为了避免在**回收新生代**时跨代**扫描整个老年代**，**CMS**和**G1**都使用了**Card Table**来记录这些**引用关系**
        - 只是**G1**在Card Table的基础上引入了**RSet**
    - 每个**Region**初始化时，都会初始化一个**RSet**，RSet记录了_**其它Region中的对象引用本Region对象的关系**_
4. CMS和G1在解决**并发标记漏标**的方式也不一样，**CMS**使用的是**Incremental Update**算法，**G1**使用的是**SATB**算法
    - 在**并发标记**中，CMS和G1都是基于**三色标记**算法实现的
        - **黑色**：节点被遍历完成，且子节点都遍历完成
        - **灰色**：当前正在遍历的节点，且子节点还没有遍历
        - **白色**：还没有遍历到的节点，即灰色节点的子节点
    - 漏标问题
        - 当一个**白色**标记对象在GC被清理掉时，正好有一个对象引用了该白色标记对象，就会出现**对象丢失**的问题
        - 如下图所示，`B->D`的引用断开，换成了`A->D`的引用，由于A已经是**黑色**，JVM不会再扫描A及其子节点了
            - 如果不做处理，那么就会**漏标D对象**
    - **CMS：Incremental Update**
        - 只要在**写屏障**里发现**一个白对象的引用被赋值到一个黑对象的字段里**，那就把这个白对象变成**灰色**的
    - **G1：STAB**
        - STAB算法认为**开始时所有能遍历到的对象**都是需要标记的，即认为**都是活**的
        - STAB的全称为`snapshot-at-the-beginning`，目的是为了维持**并发GC的正确性**
        - GC正确性：**保证存活的对象不被回收**，即不存在漏标问题，即保证回收的都是**真正的垃圾**
        - 如果标记过程是**STW**，那么**GC的正确性**肯定是能够**保证**的，但并发标记就不一定了
        - STAB：在GC开始时对内存进行一个_**对象图的逻辑快照**_
            - **只要被快照到的对象在整个GC过程中都是活的**，即使该对象的引用稍后被修改或删除
            - 同时**新分配**的对象也会被认为是**活**的，除此之外**其它不可达的对象**被认为是**死**的
        - STAB能够**保证真正存活的对象不会被GC误回收**，但也造成了可以被回收的对象逃过了GC，导致了**浮动垃圾**
5. G1具备**Pause Prediction Model**，参数`-XX:MaxGCPauseMillis`，默认值为**200ms**
    - 根据模型统计出来的**历史数据**来预测**下一次GC所需要的Region数量**，_**通过控制Region数来控制目标停顿时间**_

<img src="https://java-performance-1253868755.cos.ap-guangzhou.myqcloud.com/java-performance-gc-3color.png" width=1000/>

## GC性能指标
1. **吞吐量**
    - 吞吐量 = 应用程序耗时 / (应用程序耗时 + GC耗时)
    - 吞吐量一般**不能低于95%**
2. **停顿时间**
    - 对于串行回收器来说，停顿时间可能会比较长
    - 而使用**并发**回收器，由于垃圾收集器和应用程序**交替运行**，程序的**停顿时间会变短**
        - 但**效率**很可能**不如独占垃圾收集器**，**吞吐量**也可能**降低**
3. **GC频率**
    - 增大**堆内存**空间可以有效降低GC频率，但也意味着堆积的回收对象越多，会增加回收时的停顿时间
    - 可以适当地加大堆内存空间，保证正常的GC频率即可

## GC日志分析
1. JVM参数
    - `-XX:+PrintGC`：输出GC日志
    - `-XX:+PrintGCDetails`：输出GC的详细日志
    - `-XX:+PrintGCTimeStamps`：输出GC的时间戳（以基准时间的形式）
    - `-XX:+PrintGCDateStamps`：输出GC的时间戳（以日期的形式，如2013-05-04T21:53:59.234+0800）
    - `-XX:+PrintHeapAtGC`：在进行GC的前后打印出堆的信息
    - `-Xloggc:../logs/gc.log`：GC日志文件的输出路径
2. 分析工具
    - _**[GCeasy（推荐）](https://www.gceasy.io/index.jsp)**_
    - [GCViewer](https://sourceforge.net/projects/gcviewer/)
    
## GC调优策略

### 降低Minor GC频率
1. 由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，可以通过**增大新生代空间**来**降低Minor GC频率**
2. 单次Minor GC时间由两部分组成：T1（**扫描新生代**）+ T2（**复制存活对象**）
3. 假设一个对象在Eden区的存活时间为500ms，Minor GC的时间间隔为300ms
    - 由于该对象依然存活，Minor GC的时间为**T1+T2**
4. 如果增大新生代空间，Minor GC的时间间隔扩大到600ms
    - 此时存活时间为500ms的对象会在Eden区被回收，**不存在复制存活对象**，此时Minor GC时间为**2T1**
    - 新生代扩容后，Minor GC增加了T1，但减少了T2，通常在JVM中，_**T2远大于T1**_
5. 小结
    - 如果堆内存中**长期对象很多**，扩容新生代，反而会增加Minor GC的时间
    - 如果堆内存中**短期对象很多**，扩容新生代，_**单次Minor GC的时间不会显著增加**_
        - 单次Minor GC的时间更多地取决于**GC后存活对象的数量**，而非Eden区的大小

### 降低Full GC频率
1. 由于**堆内存空间不足**或者**老年代对象太多**，会触发Full GC（带来**上下文切换**，增加系统的**性能开销**）
2. 常见优化点：**减少创建大对象**、**增大堆内存空间（初始化堆内存为最大堆内存）**

### 选择合适的GC回收器
1. **响应速度快：CMS、G1**
2. **吞吐量高：Parallel Scavenge**

## 参考资料
[Java性能调优实战](https://time.geekbang.org/column/intro/100028001)