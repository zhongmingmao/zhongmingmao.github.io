---
title: Redis -- Pipeline
mathjax: false
date: 2019-10-10 11:36:09
categories:
    - Storage
    - Redis
tags:
    - Storage
    - Redis
---

## 消息交互

### 一次操作
客户端将请求传送给服务器，服务器处理完后再将响应回复给客户端，这需要花费**一个网络数据包来回的时间**
<img src="https://redis-1253868755.cos.ap-guangzhou.myqcloud.com/redis-pipeline-one-op.png" width=1000/>

<!-- more -->

### 多次操作
连续执行多条指令，会花费**多个网络数据包来回的时间**
<img src="https://redis-1253868755.cos.ap-guangzhou.myqcloud.com/redis-pipeline-multi-op.png" width=1000/>

在客户端代码层面，需要经历`写-读-写-读`才能完整地执行完两条指令，如果将顺序调整为`写-写-读-读`，两个指令同样能够正常完成
两个连续的写操作和两个连续的读操作总共只会花费**一次网络来回**，看起来像**合并**了一样
管道操作的本质：**客户端**通过**改变**管道中指令列表的**读写顺序**，可以**大福节省IO时间**，管道中的**指令越多**，**效果越好**
<img src="https://redis-1253868755.cos.ap-guangzhou.myqcloud.com/redis-pipeline-multi-op-merge.png" width=1000/>

## 管道本质

### 网络交互
<img src="https://redis-1253868755.cos.ap-guangzhou.myqcloud.com/redis-thread-io-model-server-client.png" width=1000/>

1. 客户端进程调用`write`函数将消息写到操作系统**内核为套接字分配的发送缓冲**`send buffer`
2. 客户端操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过网际路由送到服务器的网卡
3. 服务器操作系统内核将网卡的数据放到**内核为套接字分配的接收缓冲**`recv buffer`
4. 服务器进程调用`read`从接收缓冲中取出消息进行处理
5. 服务器进程调用`write`将响应消息写到内核为套接字分配的发送缓冲`send buffer`
6. 服务器操作系统内核将发送缓冲中的内容发送到网卡，网卡硬件将数据通过网际路由送到客户端的网卡
7. 客户端操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲`recv buffer`
8. 客户端进程调用`read`从接收缓冲中取出消息返回给上层业务逻辑进行处理

### 解析
1. `write`函数只负责将数据写到操作系统内核的**发送缓冲**，如果发送缓冲**满**了，那么需要**等待**，这是**写操作IO操作的真正耗时**
2. `read`函数只负责将数据从操作系统内核的**接收缓冲**取出来，如果接收缓冲是**空**的，那么需要**等待**，这是**读操作IO操作的真正耗时**
3. 对于`value = redis.get(key)`这个请求来说
    - `write`操作**几乎没有耗时**
        - 写到发送缓存就返回
    - `read`会**比较耗时**
        - 因为需要等待消息经过**网络路由**到达目标机器**处理**后的响应消息，再**回送**到当前的内核**接收缓冲**才可以返回
4. 对于管道来说
    - 连续的`write`操作没什么耗时
    - 之后第一个`read`操作会等待**一个网络的来回**开销
        - 然后所有的响应消息就已经回送到内核的接收缓冲了，后续的`read`操作**直接**可以从接收缓存中取出结果，速度非常快