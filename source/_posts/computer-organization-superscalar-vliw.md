---
title: 计算机组成 -- Superscalar + VLIW
mathjax: false
date: 2020-01-19 09:26:45
categories:
    - Computer Basics
    - Computer Organization
tags:
    - Computer Basics
    - Computer Organization
---

## 吞吐率
1. 程序的CPU执行时间 = 指令数 × **CPI** × Clock Cycle Time
2. CPI = Clock Per Instruction
3. **IPC = 1/CPI = Instruction Per Clock**
   - **一个时钟周期内能够执行的指令数**，代表了**CPU的吞吐率**
   - **最佳**情况下，IPC只能到**1**
     - 无论做了哪些流水线层面的优化，即使做到了**指令执行**层面的**乱序执行**
     - CPU仍然**只能在一个时钟周期内取一条指令！！**
     - 无论指令后续无论优化得多好，一个时钟周期也只能执行一条指令，**IPC只能是1**
4. 但**Intel** CPU或者**ARM** CPU，一般IPC能做到**2**以上

<img src="https://computer-composition-1253868755.cos.ap-guangzhou.myqcloud.com/computer-organization-superscalar-vliw-ipc.jpg" width=1000/>

<!-- more -->

## 多发射 + 超标量
1. **整数**计算过程和**浮点数**的计算过程**差异比较大**
   - 整数计算和浮点数计算的**电路**，在CPU层面是**分开**的
   - 一直到**80386**，CPU都是**没有专门的浮点数计算的电路**的，当时的浮点数计算，都是通过**软件**进行**模拟**的
   - 在80386时代，Intel给386配了单独的**387芯片**，专门用来做**浮点数运算**
     - **386dx**：**带**387浮点数计算芯片
     - 386sx：不带387浮点数计算芯片
2. CPU会有**多个ALU**，在**指令执行**阶段，会采用**乱序执行**，这是由很多个**功能单元**（FU）**并行**（Parallel）进行的
   - 但**取指令**（IF）和**指令译码**（ID）并不是并行的
3. **增加硬件**
   - 一次性从内存里面取出**多条指令**，然后分发给多个**并行的指令译码器**，进行译码，然后对应交给不同的功能单元去处理
     - **不同功能单元的流水线长度不同**
     - 平时所说的**14**级流水线，通常指的是进行**整数计算**指令的流水线长度，如果是浮点数运算，实际的流水线长度会更长
   - 这样在一个时钟周期内，能完成多条指令，**IPC**可以**大于1**
   - 这种CPU设计，称为**多发射**（Mulitple Issue）或者**超标量**（Superscalar）
     - **多发射**：在同一个时间，可能会**同时**把**多条指令**发射到不同的**译码器**或者后续处理的**流水线**中去
     - **超标量**：本来在一个时钟周期内，只能执行一个**标量**（Scalar）的计算，在**多发射**的情况下，能够**同时进行多次计算**
4. Intel从Pentium时代，第一次引入超标量技术，整个CPU的**性能上了一个台阶**，对应的技术，一直沿用至今
    - **超标量**技术和**流水线**技术，都是依赖于**硬件层面**能够检测到对应的**指令的先后依赖关系**，解决**冒险**问题，但使得**电路变复杂**

<img src="https://computer-composition-1253868755.cos.ap-guangzhou.myqcloud.com/computer-organization-mulitple-issue.jpg" width=1000/>
<img src="https://computer-composition-1253868755.cos.ap-guangzhou.myqcloud.com/computer-organization-superscalar.jpg" width=800/>

## 超长指令字
1. 无论是**乱序执行**，还是**超标量**，在实际的硬件层面，实施起来都比较麻烦，因为CPU要解决**依赖冲突**的问题（即**冒险**问题）
   - 在指令执行之前，需要判断指令之间是否有依赖关系，如果有对应的**依赖**关系，指令就**不能分发到执行阶段**
   - 对于**依赖关系的检测**，使得**CPU的电路**变得更加**复杂**
2. 程序的CPU执行时间 = **指令数 × CPI × Clock Cycle Time**
   - 可以通过改进**编译器**来优化**指令数**这个指标
   - 诞生了**超长指令字设计**（Very Long Instruction Word，**VLIW**），尝试通过**编译器**来优化**指令数**和**CPI**
3. 在**乱序执行**和**超标量**的CPU架构里，**指令的前后依赖关系**，是由CPU内部的**硬件电路**来检测的
   - 到了**超长指令字**的架构里面，该工作交给了**编译器**来实现
4. 编译器把**没有依赖关系**的代码位置进行**交换**，然后把**多条连续的指令**打包成一个**指令包**
5. CPU运行时，不再是取一条指令，而是**取出一个指令包**，**译码解析整个指令包**，解析出3条指令直接**并行**运行
6. 使用**超长指令字**架构的CPU，同样采用的是**流水线**架构，一组指令，仍然要经历多个时钟周期
7. **流水线停顿**这件事情在**超长指令字**架构里面，很多时候也是由**编译器**实现的
   - 除了**停下整个处理器流水线**，超长指令字架构的CPU**不能在某个时钟周期停顿一下**，等待前面依赖的操作执行完成
   - **编译器**需要在适当的位置插入**NOP**操作，直接在编译出来的**机器码**里面，就已经把**流水线停顿**这件事在**软件层面**处理了
8. 安腾处理器失败的原因
   - 安腾处理器的**指令集**和**x86**是不同的，原来x86上的所有**程序**都没办法在安腾处理器上运行，需要通过编译器**重新编译**
   - 安腾处理器的**VLIW**架构决定了如果安腾处理器需要**提升并行度**，就需要**增加一个指令包里包含的指令数**
     - 一旦从3变成6，虽然**同为VLIW架构**，**同样指令集**的安腾处理器，程序也需要**重新编译**
     - **编译器**判断**依赖关系**：3个指令以及由3个指令组成的指令包之间 -> 6个指令以及由6个指令组成的指令包之间
       - 编译器需要**重新编译**，**交换指令顺序**和**插入NOP操作**，才能满足条件
   - 不容易**向前兼容**，也不容易**向后兼容**

<img src="https://computer-composition-1253868755.cos.ap-guangzhou.myqcloud.com/computer-organization-vliw-1.jpg" width=1000/>
<img src="https://computer-composition-1253868755.cos.ap-guangzhou.myqcloud.com/computer-organization-vliw-2.jpg" width=1000/>

## 参考资料
[深入浅出计算机组成原理](https://time.geekbang.org/column/intro/100026001)