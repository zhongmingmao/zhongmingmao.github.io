---
title: 计算机组成 -- 段 + 页
mathjax: false
date: 2020-01-09 13:06:28
categories:
    - Computer Basics
    - Computer Organization
tags:
    - Computer Basics
    - Computer Organization
---

## 程序装载
1. 背景
    - 通过**链接器**，把多个目标文件合并成一个最终可执行文件
    - 运行可执行文件时，其实是通过一个**装载器**，解析`ELF`或者`PE`格式的可执行文件
      - 装载器会把对应的指令和数据加载到内存里面，让CPU去执行
2. 装载器需要满足两个条件
   - 可执行程序加载后**占用的内存空间**应该是**连续**的
     - 执行程序时，程序计数器是**顺序**地一条一条指令执行下去
   - 需要**同时加载**很多个程序，并且**不能让程序自己规定在内存中加载的位置**
3. 内存地址
    - **虚拟**内存地址：**指令**里用到的内存地址
    - **物理**内存地址：**内存硬件**里的空间地址
4. 一个思路
    - 在**物理内存**里面找一段**连续**的内存空间，分配给装载的程序
      - 然后把这段**连续的内存空间地址**和整个程序**指令里指定的内存地址**做一个**映射**
    - 程序里有指令和各种内存地址，而我们**只需要关心虚拟内存地址**即可
    - 对任何一个程序来说，它所看到的都是**同样的内存地址**
      - 维护一个**虚拟内存**到**物理内存**的**映射**表
      - 实际程序指令执行的时候，会通过虚拟内存地址，找到对应的物理内存地址，然后执行
    - 因为是**连续的内存地址空间**，只需要维护映射关系的**起始地址**和**对应的空间大小**即可

<!-- more -->

## 内存分段
1. 分段（**Segmentation**）：找出一段**连续的物理内存**和虚拟内存地址进行**映射**
2. 段：系统分配出来的那个**连续**的内存空间
3. 解决了程序本身不需要关心具体的物理内存地址的问题，但仍然存在两个问题
  - **内存碎片**（Memory Fragmentation）
  - **性能瓶颈**（内存交换用到了**硬盘**，如果需要换出的程序所占用的物理内存很大，就会很慢）

<img src="https://computer-composition-1253868755.cos.ap-guangzhou.myqcloud.com/computer-organization-segmentation-page-segmentation.png" width=1000/>

### 内存碎片
<img src="https://computer-composition-1253868755.cos.ap-guangzhou.myqcloud.com/computer-organization-segmentation-page-memory-fragmentation.png" width=1000/>

#### 内存交换
1. 内存交换：Memory Swapping
2. 把Python程序占用的256MB内存写到**硬盘**上，然后再从硬盘读回来到**内存**里面
  - 读回来的时候，不再把它加载到原来的位置，而是紧跟在已经占用了512MB内存后面
  - 这样就有了**连续**的256MB的内存空间
3. Linux会分配一个**Swap硬盘分区**，专门给Linux进行内存交换的

### 性能瓶颈
1. **虚拟内存**、**内存分段**、**内存交换**的组合仍然会遇到性能瓶颈
2. **硬盘的访问速度要比内存慢很多！！**
  - 每次内存交换，都需要把一大段连续的内存数据写入到硬盘

## 内存分页
1. 内存**分段**的主要问题：**内存碎片** + **内存交换的空间太大**
2. **分段**是分配**一整段连续的空间**给到程序，**分页**是把**整个物理内存空间**切成一段段**固定尺寸**的大小
  - 而对应程序所需要占用的**虚拟内存空间**，也同样切成一段段**固定尺寸**的大小
  - 这样一个**连续且尺寸固定**的内存空间，叫作**页**
3. 从虚拟内存到物理内存的映射，不再是拿整段连续内存的物理地址，而是按照一个个**页**来
4. 页的尺寸一般**远小于**整个程序的大小，Linux下，页大小通常是**4KB**
5. 这样，内存空间都是预先划分好了，就没有了不能使用的内存碎片，而只有被释放出来的很多4KB的页
  - 即使内存空间不够，需要让现有的、正在运行的其它程序，通过**内存交换**释放出一些内存的**页**出来
  - 这样，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多的时间
6. 内存分页的思路：**化整为零！！**

```
$ getconf PAGE_SIZE
4096
```

### 缺页错误
<img src="https://computer-composition-1253868755.cos.ap-guangzhou.myqcloud.com/computer-organization-segmentation-page-page-fault.png" width=1000/>

1. 分页的方式使得在加载程序的时候，不再需要一次性都把程序加载到物理内存中
  - 完全可以在进行虚拟内存和物理内存的**页之间的映射**之后，并不把页加载到物理内存里面
  - 只在程序运行中，需要用到对应虚拟内存里面的指令和数据时，再加载到物理内存里面去 -- **懒加载**
2. 操作系统
  - 当要读取特定的页，却发现数据并没有加载到物理内存里面，就会触发一个**来自于CPU的缺页错误**（Page Fault）
  - **操作系统会捕捉到缺页错误**，然后将对应的页，从存放在硬盘上的虚拟内存读取出来，加载到物理内存里面
3. 好处
  - 可以运行那些**远大于**我们实际物理内存的程序（如大型游戏）
  - 任何程序都不需要一次性加载完所有指令和数据，**按需加载**即可
4. 通过**虚拟内存**、**内存分页**、**内存交换**的结合，可以让程序不再需要考虑**物理地址**、**程序加载**、**内存管理**等问题
  - 对任何一个程序来说，都只需要把内存当成一块**完整且连续**的空间来直接使用即可

## 参考资料
[深入浅出计算机组成原理](https://time.geekbang.org/column/intro/100026001)