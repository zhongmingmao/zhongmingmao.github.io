---
title: Go - CSP
mathjax: false
date: 2023-01-15 00:06:25
cover: https://go-1253868755.cos.ap-guangzhou.myqcloud.com/foundation/go-csp.webp
categories:
  - Go
tags:
  - Go
  - Cloud
  - Native
---

# 并发 vs 并行

## 单核

### 单进程

> 内部仅有一条代码执行流，不存在`竞态`，无需考虑`同步`问题

![image-20231124082840830](https://go-1253868755.cos.ap-guangzhou.myqcloud.com/foundation/image-20231124082840830.png)

<!-- more -->

1. 每个`单进程应用`对应一个操作系统`进程`
2. 操作系统的多个进程按照`时间片`大小，被`轮流调度`到`单核`上执行
3. 单核在`某个时刻`只能执行一个进程对应的程序代码，两个进程不存在`并行`执行的可能
   - `并行`（Parallelism）：在`同一时刻`，有`两个或两个以上`的进程的代码在处理器上执行
   - 因此，`多处理器`或者`多核处理器`是并行执行的`必要条件`

### 多进程

> 应用结构清晰，维护性更好

![image-20231124083731320](https://go-1253868755.cos.ap-guangzhou.myqcloud.com/foundation/image-20231124083731320.png)

1. 应用通过 `fork` 等系统调用创建多个子进程，共同实现应用的功能
2. App1 内部划分为多个模块，每个模块用一个`进程`来承载执行，每个模块都是一个单独的`执行流`
3. 在单核下，多进程依然无法并行执行，只能按照`时间片`被操作系统调度到单核上执行

## 多核

### 多线程

![image-20231124084628590](https://go-1253868755.cos.ap-guangzhou.myqcloud.com/foundation/image-20231124084628590.png)

1. 进程并不适合用于承载采用了`并发设计`的应用的模块执行流
   - 进程是操作系统中`资源分配`的基本单位：应用代码+应用数据、操作系统资源（文件描述符、内存地址空间等）
   - 因此，进程的创建、切换和撤销的`代价`都很大
2. 线程是运行于`进程上下文`中的`更轻量`的`执行流`
3. 随着处理器技术的发展，`多核处理器`成为了主流，让`真正的并行`成为了可能
4. 基于线程的应用通常采用`单进程多线程`的模型
   - `一个应用`对应`一个进程`，应用通过`并发设计`将自身划分为多个`模块`，每个模块由一个`线程`独立承载执行
   - 多个线程`共享`该进程内的资源，而线程作为`执行单元`可以被`独立调度`到`处理器`上执行
     - 线程的创建、切换和撤销的代价相对于进程要`小得多`
   - 当应用的多个线程`同时`被调度到`不同`的处理器核上执行时，该应用是`并行`的

## 对比

> `并发`关乎`结构`、而`并行`关乎`执行`

1. 并发是应用`设计`和`实现`阶段要考虑的问题
   - 考虑如何将应用`划分`为多个相互配合、可独立执行的`模块`
   - 采用`并发设计`的程序并不一定是`并行执行`的，如仅有一个单核 CPU
2. 并发让并行`变得容易`
   - 采用`并发设计`的应用可以将负载自然扩展到各个 CPU 核上，从而提升处理器的利用效率

> `并发`是一种`能力`，让程序可以由若干代码片段`组合`而成，并且每个片段都是`独立运行`的

> `并行`的`必要条件`是具有`多个处理器`或者`多核处理器`

# 原生线程

1. 在传统编程语言（C++、Java）中，基于`多线程模型`的应用设计，是一种典型的`并发设计`
2. 但并非`面向并发`而生，多以`操作系统线程`作为承载分解后的代码片段的`执行单元`，由`操作系统执行调度`

> 不足

1. `复杂`
   - 在 C++ 中，线程`创建容易退出难`
   - 并发执行单元间的`通信困难且易错`
     - 一旦涉及到`共享内存`，会涉及到各种`锁互斥`机制，容易造成`死锁`
   - 需要设定`线程栈大小`
2. `难以规模化`
   - 线程的使用代价虽然远小于进程，但依然`不能创建大量线程`
     - 每个线程会`占用不小的资源`，且操作系统`调度切换`线程的代价也不小
   - 对于`网络服务`而言，只能基于少量线程做`IO 多路复用`

# goroutine

> `goroutine` - 由 `Go Runtime` 负责调度的`轻量级用户线程`，为`并发设计`提供了`原生支持`

## 优势

> 占用资源少 + 在用户层调度 + 支持 CSP 模型

1. 占用资源小，每个 goroutine 的`初始栈大小`仅为 `2K`
2. 由 `Go Runtime` 而非操作系统`调度`，goroutine 上下文切换在`用户层`完成，开销更小
3. 在`语言层面`而不是通过标准库提供
   - goroutine 由 go 关键字创建，`一退出`就会被`回收`或者`销毁`，开发体验更佳
4. 语言内置 `channel` 作为 goroutine 间的`通信原语`，为并发设计提供了强大支撑

## 用法

> 无论是 Go Runtime 代码，还是用户层代码，都运行在 goroutine 中

```go
// 基于已有的具名函数
go fmt.Println("I am a goroutine")

// 基于匿名函数/闭包
var c = make(chan int)
go func(a, b int) {
  c <- a + b
}(3, 4)
```

```go net/http/server.go
// 基于已有的具名方法
c := srv.newConn(rw)
go c.serve(connCtx)
```

1. 一个应用内部启动的所有 goroutine `共享`进程空间的资源
2. 如果多个 goroutine 访问`同一块`内存数据，将会存在`竞争`，此时需要进行 goroutine 之间的`同步`

> 退出 goroutine

1. goroutine 的`使用代价很低`，goroutine 的`执行函数返回`，意味着 goroutine 退出
2. 如果 `main goroutine` 退出，意味着`整个应用`退出

> goroutine 执行的`函数`或者`方法`即便有`返回值`，Go 也会`忽略`这些返回值

## 通信

### 传统

1. 传统的编程语言（C++、Java 等）并非`面向并发`而生，所以面向并发的逻辑多是基于`操作系统线程`
   - 并发的`执行单元`（线程）之间的通信，利用的也是`操作系统`提供的`线程`或者`进程`间通信的`原语`
     - 如：共享内存、信号、管道、消息队列、套接字等
     - 使用最广泛的是结合了`线程同步原语`（`锁`以及更为低级的`原子`操作）的`共享内存`方式
2. 传统编程语言的`并发模型`是基于`共享内存`的 - `难用` + `易错`

### CSP

> Communicating sequential processes，CSP 模型旨在`简化并发程序的编写`

1. 输入输出为基本的编程原语，数据处理逻辑（`P`）调用输入原语获取数据，顺序处理数据，并将结果输出到输出原语
2. 一个符合 CSP 模型的并发程序应该是一组通过`输入输出`原语`连接`起来的 `P 集合`
   - CSP 的`组合`思想与 Go 的设计哲学不谋而合

> `sequential processes`
> P 为一个抽象概念，代表任何`顺序处理逻辑`的封装，获得输入数据，并生产可以被其它 P 消费的输出数据

![image-20231125103915703](https://go-1253868755.cos.ap-guangzhou.myqcloud.com/foundation/image-20231125103915703.png)

1. P 不一定就是操作系统的进程或者线程，在 Go 中，`P` 就是 `goroutine`
2. 为了实现 CSP 并发模型中的`输入输出原语`，Go 引入了 goroutine 之间的通信原语 `channel`
3. 通过 channel 将 goroutine `组合`连接在一起

```go
func spawn(f func() error) <-chan error {
	c := make(chan error)

	go func() {
		c <- f()
	}()

	return c
}

func main() {
	c := spawn(func() error {
		time.Sleep((1 << 1) * time.Second)
		return errors.New("timeout")
	})

	fmt.Println(<-c) // timeout
}
```

1. `CSP` 为 Go 支持的`主流`并发模型 - `推荐`
2. Go 也支持`基于共享内存`的并发模型
   - 提供基本的`低级别同步原语`，如 sync 包中`互斥锁`、`条件变量`、`读写锁`、`原子操作`等

