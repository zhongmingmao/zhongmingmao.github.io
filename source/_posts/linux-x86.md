---
title: Linux -- x86架构
date: 2019-04-09 08:05:58
categories:
    - Linux
tags:
    - Linux
---

## 计算机的工作模式
<img src="https://linux-1253868755.cos.ap-guangzhou.myqcloud.com/linux-computer-working-mode.jpg" width=800/>

<!-- more -->

1. 对于一个计算机来说，最**核心**的是CPU，CPU是计算机的大脑，所有设备都围绕其展开
2. CPU通过**总线**（Bus）与其他设备连接，在这些设备中，最为重要的是**内存**（Memory）
3. 单靠CPU是无法完成计算任务的，很多复杂的计算任务都需要将**中间结果**保存下来，然后基于中间结果进行下一步的计算
    - CPU本身无法保存这么多的中间结果，因此需要依赖于内存
4. CPU和内存是**完成计算**的核心组件

### CPU
1. CPU包含三部分：_**运算单元、数据单元和控制单元**_
2. 运算单元只管计算，但它不知道应该算哪些数据，运算结果应该放在哪里
3. 运算单元计算的数据如果每次都要经过总线，直接到内存里面现拿，速度会很**慢**，因此出现了_**数据单元**_
4. 数据单元包括CPU内部的**缓存**和**寄存器组**，空间很小，但速度很快
5. 控制单元是一个**统一的指挥中心**，可以获得下一条指令，然后执行这条指令
    - 这个指令会指导运算单元取出数据单元中的某几个数据，计算出结果，然后放在数据单元的某个地方

### 计算过程
<img src="https://linux-1253868755.cos.ap-guangzhou.myqcloud.com/linux-cal-process.jpg"/>
1. 每个进程都有一个程序放在**硬盘**上，是**二进制**的，在里面存储的是一行一行的**指令**，这些指令会操作一些数据
2. 进程开始运行，会有**独立**的内存空间，_**相互隔离但不连续**_
    - 程序会分别加载到进程A和进程B的内存空间里面，形成各自的_**代码段**_
3. 程序在运行过程中要操作的数据和产生的计算结果，都会放在**数据段**（内存）里
4. 在CPU的**控制单元**里面，有一个**指令指针寄存器**，记录的是_**下一条指令在内存中的地址**_
    - 控制单元会不停地将**代码段的指令**拿进来，先放入_**指令寄存器**_
5. 指令的组成部分：_**做什么操作**_ + _**操作哪些数据**_
    - 要执行指令，需要将第一部分交给**运算单元**，将第二部分交给**数据单元**
6. 数据单元根据**数据的地址**，从**数据段**里读取数据到**数据寄存器**，最终会有指令将数据写回到**内存中的数据段**
7. CPU里有两个寄存器，专门保存**当前处理进程**的**代码段起始地址**和**数据段起始地址**，图中的当前进程为进程A
8. CPU和内存通过**总线**传输数据，总线上有两类数据
    - _**地址总线**_（Address Bus）：地址数据，位数决定了**能访问的地址**有多广
    - _**数据总线**_（Data Bus）：真正的数据，位数决定了**一次性能拿多少数据**

## x86架构

### 型号
| 型号 | 总线位宽 | 地址位 | 寻址空间 |
| ---- | ---- | ---- | ---- |
| 8080 | 8 | 16 | 64K |
| 8086 | 16 | 20 | 1M |
| 8088 | 8 | 20 | 1M |
| 80386 | 32 | 32 | 4G |

### 8086的原理
<img src="https://linux-1253868755.cos.ap-guangzhou.myqcloud.com/linux-8086.jpg"/>

#### 通用寄存器
1. 为了**暂存数据**，8086处理器内部有8个16位的**通用寄存器**，属于CPU内部的_**数据单元**_
2. 分别是AX、BX、CX、DX、SP、BP、SI和DI
3. 其中AX、BX、CX和DX可以分成两个8位的寄存器来使用，其中H就是High，L就是Low
4. 这样，比较长的数据也能暂存，比较短的数据也能暂存

#### 控制单元
- IP寄存器（Instruction Pointer Register）即_**指令指针寄存器**_
    - 指向**代码段**中**下一条指令的位置**
    - CPU会根据**IP寄存器**不断地将指令从**内存的代码段**中，加载到CPU的**指令队列**中，然后交给**运算单元**去执行
- _**切换进程**_
    - 每个进程都分为**代码段**和**数据段**
    - 为了指向不同进程的地址空间，有4个16位的**段寄存器**，分别是CS、DS、SS和ES
- CS（Code Segment Register）是**代码段寄存器**，通过它可以找到代码在内存中的位置
- DS（Data Segment Register）是**数据段寄存器**，通过它可以找到数据在内存中的位置
- SS（Stack Segment Register）是**栈寄存器**，但凡与**函数调用**相关的操作，都与栈紧密相关
    - A调用B，B调用C
    - 当A调用B的时候，要执行B函数的逻辑，因而A运行的相关信息会被push到栈里
    - 当B调用C的时候，同理，B运行的相关信息会被push到栈里，然后才运行C函数的逻辑
    - 当C运行完毕后，先pop出来的是B，B接着调用C函数之后的指令运行下去
    - B运行完毕后，再pop出来的是A，A接着运行，直至结束

<img src="https://linux-1253868755.cos.ap-guangzhou.myqcloud.com/linux-8086-ss-function-call.jpg" width=600/>

#### 加载内存数据
1. 如果需要加载内存中的数据，可以通过DS找到内存中的数据，加载到_**通用寄存器**_
2. 对于一个段，有一个**起始地址**，而**段内**的具体位置，称为_**偏移量**_
3. CS和DS都存放着一个_**段的起始地址**_
    - 代码段的偏移量放在**IP寄存器**
    - 数据段的偏移量放在**通用寄存器**
4. CS和DS都是16位的（**起始地址**），IP寄存器和通用寄存器也都是16位的（**偏移量**），但8086的地址总线是20位的
    - 凑20位：_**起始地址 << 4 + 偏移量**_
5. 无论真正的内存有多大，对于只有20位地址总线的8086来说，能够区分的地址也就`2^20=1M`（寻址单位为**Byte**）
    - 如果想访问1M+X的地方，在总线上超过20位的部分根本发不出去，最后访问的还是1M内的X位置
6. 偏移量只有16位的，所以一个段的最大大小为`2^16=64K`
7. 因此对于8086的CPU来说，最多只能访问1M的内存空间，还要分成多个段，每个段最大为64K

## 32位处理器
1. 在32位的CPU中，有32根地址总线，可以访问`2^32=4G`的内存
2. x86架构是开放的，因此32位的CPU需要兼容原来的架构

### 兼容
<img src="https://linux-1253868755.cos.ap-guangzhou.myqcloud.com/linux-8086-32bit-compatible.jpg"/>
1. 通用寄存器
    - 将8个16位的通用寄存器扩展到8个32位的通用寄存器，但依然保留16位和8位的使用方式
    - **高16位不能分成两个8位使用**，因为这是**不兼容**的
2. IP寄存器
    - 指向下一条指令的**指令指针寄存器**IP，会扩展成32位的，同样兼容16位
3. 段寄存器（Segment Register）
    - CS、DS、SS和ES仍然是16位，但**不再是段的起始地址**，段的起始地址放在内存的某个地方（**表格**）
    - 表格中的一项是**段描述符**（Segment Descriptor），里面才是_**段真正的起始地址**_
    - 而**段寄存器**里面保存的是这个表格中的某一项，称为**选择子**（Selector）
    - 获取段起始地址的流程：先**间接**地从段寄存器中找到表格中的一项，再从表格中的一项拿到_**段真正的起始地址**_
    - 为了快速拿到段的起始地址，段寄存器会从内存中拿到CPU的**描述符高速缓存器**中
    - 这种模式与8086的模式不兼容，但**非常灵活**，可以_**保持未来的兼容性**_

### 实模式 VS 保护模式
1. 在32位的架构下，将前一种模式称为**实模式**（Real Pattern），后一种模式称为**保护模式**（Protected Pattern）
2. 系统**刚刚启动**的时候，CPU处于**实模式**，此时和原来的模式是**兼容**的
    - 即32位的CPU，也支持在原来的模式下运行，速度会快一点
3. 当需要更多内存时，可以遵循一定的规则，进行一系列的操作，然后切换到**保护模式**，就能够用到32位CPU更强大的能力
4. 如果不能无缝兼容，但**通过切换模式兼容**，也是**可以接受**的

### 系统交互
<img src="https://linux-1253868755.cos.ap-guangzhou.myqcloud.com/linux-8086-32bit-interaction.jpg"/>

## 常用汇编指令
```
mov, call, jmp, int, ret, add, or, xor, shl, shr, push, pop, inc, dec, sub, cmp
```

<!-- indicate-the-source -->
