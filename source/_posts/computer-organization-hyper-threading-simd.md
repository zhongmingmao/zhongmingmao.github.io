---
title: 计算机组成 -- 超线程 + SIMD
mathjax: false
date: 2020-01-20 00:59:50
categories:
    - Computer Basics
    - Computer Organization
tags:
    - Computer Basics
    - Computer Organization
---

## 超线程 -- 线程级并行

### Pentium 4
1. Pentium 4失败的原因：**CPU的流水线级数太深**
2. 超长的流水线，使得之前很多**解决冒险**、**提升并发**的方案都用不上
3. 解决冒险、提升并发的方案，本质上是一种**指令级并行**的技术方案，即CPU希望在同一个时间，去**并行执行两条指令**
  - 但这两条指令，原本在代码里是有**先后顺序**的
4. 无论是**流水线架构**、**分支预测**以及**乱序执行**，还是**超标量**和**超长指令字**
  - 都是想通过在同一时间执行两条指令，来提升CPU的**吞吐率**
  - 但在Pentium 4上，上面这些方法都可能因为**流水线太深**，而**起不到效果**
  - 更深的流水线意味着**同时在流水线里面的指令就很多，相互的依赖关系就多**
  - 因此，很多时候不得不把**流水线停顿**下来，**插入很多NOP操作**，来解决这些**依赖**带来的**冒险**问题

<!-- more -->

### 超线程
1. 无论是多个CPU核心运行不同的程序，还是单个CPU核心里切换运行不同线程的任务
   - 在**同一时间**点上，**一个物理的CPU核心只会运行一个线程的指令**，其实并没有做到真正的**指令级并行**
2. 超线程的CPU，把一个**物理**层面的CPU核心，**伪装**成两个**逻辑**层面的CPU核心
   - 这个CPU会在硬件层面**增加很多电路**，使得可以在一个CPU核心内部，**维护两个不同线程的指令的状态信息**
   - 在一个物理CPU核心内部，会有**双份**的**PC寄存器**、**指令寄存器**、**条件码寄存器**
   - 在外面看来，似乎有**两个逻辑层面的CPU在同时运行**
   - 因此，超线程技术也被叫为**同时多线程**（Simultaneous Multi-Threading，**SMT**）技术
3. 但CPU的**其它**功能组件，**没有提供双份**，无论是**指令译码器**还是**ALU**，一个物理CPU核心仍然只有一份
   - 因为**超线程并不是真的去同时运行两个指令**
   - 超线程的目的：在线程A的指令在**流水线停顿**的时候，让线程B去执行指令，此时CPU的**指令译码器**和**ALU**是**空闲**的
     - 线程B**没有**对线程A里面的指令有关联和**依赖**
4. CPU通过**很小的代价**，就能实现同时运行多个线程的效果
    - 只需要在CPU核心增加**10%左右的逻辑功能**，增加**可以忽略不计的晶体管数量**
5. 超线程并**没有增加功能单元（ALU）**，所以超线程只在**特定的应用场景**下效果比较好
   - 一般是**各个线程等待时间比较长**的应用场景
   - 例如需要应对很多请求的**数据库应用**，就比较适合使用超线程，各个指令都要**等待访问内存数据**，但并**不需要做太多计算**

<img src="https://computer-composition-1253868755.cos.ap-guangzhou.myqcloud.com/computer-organization-hyper-threading.jpg" width=1000/>

## SIMD -- 指令级并行
1. **SIMD**：Single Instruction Multiple Data，**单指令多数据流**，支持SIMD的指令集：**MMX**、**SSE**
2. 两段代码
   - 通过**循环**的方式，给list里面的每一个数加1
   - 实现相同的功能，直接调用**NumPy**库的add方法
   - 性能差异：**32.72**
3. 原因：NumPy直接用了**SIMD指令**，能够**并行**进行**向量的操作**
   - 通过**循环**来一步一步计算的算法，称为**SISD**，**单指令单数据**
   - 如果是**多核CPU**，可以同时处理多个指令的方式称为**MIMD**，**多指令多数据**
4. SIMD在**获取数据**和**执行指令**的时候，都做了**并行**
   - **从内存读取数据**的时候，SIMD**一次性读取多个数据**
     - 下面程序数组里面的元素是**integer**，需要**4Bytes**的内存空间
     - Intel在引入**SSE**指令集的时候，在CPU里添加了**8个128Bits的寄存器**
       - **128Bits ≈ 16Bytes**，即一个寄存器可以**一次性加载4个整数**
       - 比循环分别读取4次对应的数据，能节省不少时间
   - 在数据读取之后，到了指令的**执行**层面，SIMD也是可以**并行执行**的
     - 4个整数各自加1，互相之间**完全没有依赖**，即**不需要处理冒险问题**
     - 只要CPU里有**足够的功能单元**，能够同时进行这些计算，那这个加法就是**4路同时并行**的
     - 因此那些在**计算层面**存在大量『**数据并行**』的计算中，使用SIMD能够很好地提升性能
   - 实践：**向量运算**（同一向量的不同维度之间的计算是**相互独立**的）、**矩阵运算**
     - 图片、视频、音频的处理
     - 机器学习算法的计算
5. 基于**SIMD**的**向量计算指令**，是在Intel发布Pentium处理器的时候引入的指令集
   - 当时的指令集叫作**MMX**（Matrix Math eXtensions，**矩阵数学扩展**）
   - Pentium处理器，第一个有能力进行**多媒体处理**的CPU

```python
$ python
>>> import numpy as np
>>> import timeit
>>> a = list(range(1000))
>>> b = np.array(range(1000))
>>> timeit.timeit("[i + 1 for i in a]", setup="from __main__ import a", number=1000000)
32.260748863220215
>>> timeit.timeit("np.add(1, b)", setup="from __main__ import np, b", number=1000000)
0.9859158992767334
```

<img src="https://computer-composition-1253868755.cos.ap-guangzhou.myqcloud.com/computer-organization-simd.jpg" width=1000/>

## 参考资料
[深入浅出计算机组成原理](https://time.geekbang.org/column/intro/100026001)