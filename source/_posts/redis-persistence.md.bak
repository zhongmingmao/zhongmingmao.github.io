---
title: Redis -- 持久化
mathjax: false
date: 2019-10-09 18:11:23
categories:
    - Storage
    - Redis
tags:
    - Storage
    - Redis
---

## 持久化机制
1. Redis有两种持久化机制，一种是**快照**，另一种是**AOF日志**
2. **快照**是一次**全量备份**，**AOF日志**是连续的**增量备份**
3. **快照**是**内存数据的二进制序列化形式**，在存储上非常**紧凑**，**AOF日志**记录的是**内存数据修改的指令记录文本**
    - **AOF日志**在**长期**的运行过程中会变得很**庞大**，数据库**重启**时需要加载AOF日志进行**指令重放**，时间很**漫长**
    - 因此需要**定期**进行**AOF重写**，给**AOF日志**进行**瘦身**

<img src="https://redis-1253868755.cos.ap-guangzhou.myqcloud.com/redis-persistence.png" width=1000/>

<!-- more -->

## 快照原理
1. Redis是**单线程**程序，要同时负责多个**客户端套接字的并发读写操作**和**内存数据结构的逻辑读写**
2. 在**服务线上请求**的同时，Redis还需要进行**内存快照**
    - 内存快照要求Redis必须进行**文件IO操作**，可文件IO操作是**不能使用多路复用API**的
    - 存在的挑战
        - 单线程同时在服务线上的请求还要进行文件IO操作，而文件IO操作会**严重拖垮服务器请求的性能**
        - 为了不阻塞线上的业务，需要**边持久化边响应**客户端请求
    - Redis使用操作系统的**多进程COW（Copy On Write）**机制来实现快照持久化

### Fork多进程
1. Redis在持久化时会调用`glibc`的`fork`函数产生一个子进程，**快照持久化完全交给子进程来处理**，父进程继续处理客户端请求
2. 子进程刚产生时，和父进程**共享**内存里的**代码段**和**数据段**，在进程分离那一瞬间，**内存的增长几乎没有明显变化**
3. **子进程**做数据持久化，**不会修改**现有的内存数据结构，只是对数据结构进行**遍历读取**，然后**序列化**写到**磁盘**中
4. **父进程**必须持续服务客户端请求，然后对内存数据结构进行**不间断地修改**
    - 此时会使用操作系统的**COW机制**来进行**数据段页面的分离**
    - 当父进程对数据段中的一个页面进行修改时，会将被共享的页面**复制**一份**分离**出去，然后对这个复制的页面进行**修改**
    - 此时**子进程相应的页面没有变化**，还是子进程产生时那一瞬间的数据，因此称为**快照**
5. 随着父进程修改操作的持续进行，越来越多的共享页面被分离出去，内存会持续增长，但也不会超过原有数据内存大小的两倍

```python
# 父进程里返回子进程的pid，子进程里返回0，如果操作系统内存资源不足，pid为负，表示fork失败
pid = os.fork()
if pid > 0:
    handle_client_requests()    # 父进程继续处理客户端请求
if pid == 0:
    handle_snapshot_write()     # 子进程处理快照写磁盘
if pid < 0:
    # fork error
```

## AOF原理
1. AOF：**Append Only File**
2. AOF日志存储的是Redis服务器的**顺序指令序列**，AOF日志只记录对内存进行修改的指令记录
3. **执行指令 -> 日志存盘**
    - Redis会在收到客户端修改指令后，进行参数校验进行逻辑处理后，如果没问题，会立即将该指令文本存储到AOF日志中
4. Redis在长期运行的过程中，AOF日志会**越来越大**
    - 如果实例宕机重启，**重放整个AOF日志会非常耗时**，导致长时间Redis**无法对外提供服务**，所以需要对AOF日志**瘦身**

### AOF重写
1. Redis提供了**`bgrewriteaof`**指令用于对AOF日志进行瘦身
2. 原理
    - 开辟一个子进程**对内存进行遍历**转换成一系列Redis操作指令，**序列化**到一个**新的AOF日志文件**中
    - 序列化完毕后再将操作期间发生的**增量AOF日志**追加到新的AOF日志文件中，追加完成后立马**替换**旧的AOF日志

### fsync
1. AOF日志是以**文件**的形式存在的，当程序对AOF日志文件进行**写操作**时
    - 实际上是将内容写到**内核为文件描述符分配的一个内存缓冲区**中，然后内核会**异步将脏数据刷回磁盘**
    - 如果机器突然**宕机**，AOF日志内容可能还没来得及完全刷到磁盘上，此时会出现**日志丢失**
2. `glibc`提供了`fsync(int fd)`函数可以将指定文件的内容_**强制从内核缓存刷新到磁盘**_
    - 只要Redis进程**实时调用**`fsync`函数就可以保证**AOF日志不丢失**，但`fsync`是一个**磁盘IO**操作，**非常慢**
    - 在生产环境中，Redis通常每隔**1S**（可配置）左右就执行一次`fsync`操作，在保持**高性能**的同时，**尽可能少丢失数据**
3. Redis提供了另外两种策略
    - 一种是**永远不`fsync`**，让操作系统来决定何时同步磁盘，很不安全
    - 一种是**每个指令都执行`fsync`**，很慢

## 运维
1. **快照**是通过**开启子进程**的方式进行的，是一个**比较耗资源**的操作
    - 遍历**整个内存**，**大量写磁盘**会加重系统负载
2. AOF的`fsync`是一个耗时的**磁盘IO**操作，会降低Redis性能，同时会增加系统IO负担
3. 通常Redis主节点不会进行持久化操作，**持久化操作主要在从节点进行**
    - 这里的从节点指的是**备份节点**，没有来自客户端请求的压力

## 混合持久化
1. 重启Redis，**很少使用rdb**来恢复内存状态，因为会**丢失大量数据**
    - 通常使用**AOF日志重放**，但重放AOF日志相对rdb来说要**慢很多**
2. Redis 4.0为了解决该问题，引入了_**混合持久化**_
    - 将**rdb文件的内容**和**增量的AOF日志文件**存在一起
    - 增量AOF日志：自持久化**开始**到持久化**结束**这段时间发生的增量AOF日志，通常这部分AOF日志**很小**
    - Redis重启时，先加载rdb的内容，再重放增量AOF日志，**重启效率大幅提升**

<img src="https://redis-1253868755.cos.ap-guangzhou.myqcloud.com/redis-persistence-hybrid.png" width=1000/>