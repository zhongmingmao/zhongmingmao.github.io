---
title: eBPF - Principle
mathjax: true
date: 2024-10-18 00:06:25
cover: https://ebpf-1253868755.cos.ap-guangzhou.myqcloud.com/ebpf-principle.png
categories:
  - eBPF
tags:
  - eBPF
  - Observability
---

# 发展历程

1. **1992** 年，在 BSD 操作系统中引入了**革命性**的包过滤机制 **BPF**，性能非常好
2. BPF 的两大设计
   - **内核态**引入一个新的**虚拟机**，所有指令都在**内核虚拟机**中运行
   - **用户态**使用 **BPF 字节码**来定义**过滤表达式**，然后**传递给内核**，由内核虚拟机**解释执行**
3. BPF 使得**包过滤**可以直接在**内核**中执行，**避免向用户态复制每个数据包**，从而极大提升了包过滤的性能，被各大**操作系统**广泛接受
4. BPF 诞生 5 年后，在 **Linux 2.1.75** 首次**引入**了 BPF 技术，在 **Linux 3.0** 中增加的 **BPF JIT**，替换掉性能更差的**解释器**，进一步优化了 BPF 指令运行的**效率**
5. 直到此时，**BPF** 的应用领域还仅限于**网络包过滤**
6. **2014** 年，将 BPF 扩展为一个**通用的虚拟机**，即 **eBPF**
   - eBPF 不仅扩展了**寄存器的数量**，引入了**全新的 BPF 映射存储**
   - 还在 **4.x** 内核中将原本**单一的数据包过滤事件**逐步扩展到了**内核态函数**、**用户态函数**、**跟踪点**、**性能事件**以及**安全控制**等
7. eBPF 的诞生了 BPF 技术的**转折点**，使得 BPF 不再仅限于**网络栈**，而是成为**内核**的一个**顶级子系统** - 最活跃
8. eBPF 无需**修改内核源码**和**重新编译**就可以**扩展内核**的功能

<!-- more -->

![b44562381748de369b50403219c0d1ff](https://ebpf-1253868755.cos.ap-guangzhou.myqcloud.com/b44562381748de369b50403219c0d1ff.jpg)

# 工作原理

1. eBPF 程序并不像**常规的线程**那样，启动后就一直运行在那里，它需要**内核事件触发**后才会**执行**
   - 事件 - **系统调用**、**内核跟踪点**、**内核函数**和**用户态函数**的**调用退出**、**网络事件**等
2. 借助于强大的**内核态**插桩（**kprobe**）和**用户态**插桩（**uprobe**），eBPF 程序几乎可以在**内核和应用的任意位置**进行**插桩**
3. 确保**安全**和**稳定**是 eBPF 的**首要任务**，不安全的 eBPF 程序**不会提交**到**内核虚拟机**中执行

> 执行过程

![linux_ebpf_internals](https://ebpf-1253868755.cos.ap-guangzhou.myqcloud.com/linux_ebpf_internals.png)

1. 借助 **LLVM** 把编写的 **eBPF 程序**转换为 **BPF 字节码**，然后再通过 **bpf 系统调用**提交给**内核**执行
2. 内核在接受 BPF 字节码之前，会首先通过**验证器**对**字节码**进行**校验**，只有**校验通过**的 **BPF 字节码**才会**提交**到 **JIT** 执行
3. 如果 BPF 字节码中包含了**不安全**的操作，验证器会**直接拒绝** BPF 程序的执行，典型的验证过程
   - 只有**特权进程**才可以执行 **bpf 系统调用**
   - BPF 程序不能包含**无限循环**
   - BPF 程序不能导致**内核崩溃**
   - BPF 程序必须在**有限时间**内完成
4. **BPF 程序**可以利用 **BPF 映射**进行**存储**，而**用户程序**也需要通过 **BPF 映射**与**运行在内核中的 BPF 程序**进行**交互**
5. **eBPF 程序**的运行需要经历**编译**、**加载**、**验证**和**内核态执行**等过程，而**用户态程序**则需要借助 **BPF 映射**来获取**内核态 eBPF 程序的运行状态**

> 在**性能观测**中，BPF 程序收集**内核运行状态**存储在 **BPF 映射**中，**用户程序**再从 **BPF 映射**中读取这些状态

![ebpf-maps](https://ebpf-1253868755.cos.ap-guangzhou.myqcloud.com/ebpf-maps.webp)

# 局限性

1. eBPF 程序必须被**验证器校验通过**才能执行，且不能包含**无法到达的指令**
2. eBPF 程序**不能随意调用内核函数**，只能调用在 **API** 中**定义**的**辅助函数**
3. eBPF 程序**栈**空间最多只有 **512 字节**，要**更大的存储**，只能借助于 **BPF 映射**
4. 在内核 **5.2** 之前，eBPF 字节码最多只支持 **4096 条指令**，在 5.2 内核版本将该限制提高到了 **100 万条**
5. 内核快速发展，在**不同版本内核**中运行时，需要**访问内核数据结构**的 eBPF 程序很可能需要**调整源码**，并**重新编译**
6. eBPF 很多新特性都是在 **4.x** 版本中才逐步增加的，要**稳定运行** eBPF 程序，内核版本至少要 **4.9+**，推荐 **5.x**
