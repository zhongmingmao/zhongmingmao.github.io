<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Kafka -- 消费者 | ByteCoding</title><meta name="author" content="zhongmingmao"><meta name="copyright" content="zhongmingmao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="基本概念消费者 + 消费者群组 消费者从属于消费者群组 一个消费者群组里的消费者订阅的是同一个主题，每个消费者接收主题的部分分区的消息  消费者横向扩展1个消费者   主题T1有4个分区，然后创建消费者C1，C1是消费者群组G1里唯一的消费者，C1订阅T1 消费者C1将接收主题T1的全部4个分区的消息">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka -- 消费者">
<meta property="og:url" content="https://blog.zhongmingmao.top/2018/10/18/kafka-consume/index.html">
<meta property="og:site_name" content="ByteCoding">
<meta property="og:description" content="基本概念消费者 + 消费者群组 消费者从属于消费者群组 一个消费者群组里的消费者订阅的是同一个主题，每个消费者接收主题的部分分区的消息  消费者横向扩展1个消费者   主题T1有4个分区，然后创建消费者C1，C1是消费者群组G1里唯一的消费者，C1订阅T1 消费者C1将接收主题T1的全部4个分区的消息">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-24.png">
<meta property="article:published_time" content="2018-10-18T07:30:51.000Z">
<meta property="article:modified_time" content="2023-04-03T10:04:59.590Z">
<meta property="article:author" content="zhongmingmao">
<meta property="article:tag" content="Middleware">
<meta property="article:tag" content="MQ">
<meta property="article:tag" content="Kafka">
<meta property="article:tag" content="Stream">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-24.png"><link rel="shortcut icon" href="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/z.png"><link rel="canonical" href="https://blog.zhongmingmao.top/2018/10/18/kafka-consume/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":512,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":256},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":32,"languages":{"author":"Author: zhongmingmao","link":"Link: ","source":"Source: ByteCoding","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kafka -- 消费者',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-03 18:04:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ByteCoding" type="application/atom+xml">
</head><body><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/z.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">633</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">189</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">80</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-24.png')"><nav id="nav"><span id="blog-info"><a href="/" title="ByteCoding"><span class="site-name">ByteCoding</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Kafka -- 消费者</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2018-10-18T07:30:51.000Z" title="Created 2018-10-18 15:30:51">2018-10-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/middleware/">Middleware</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/middleware/mq/">MQ</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/middleware/mq/kafka/">Kafka</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">6.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>22min</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="消费者-消费者群组"><a href="#消费者-消费者群组" class="headerlink" title="消费者 + 消费者群组"></a>消费者 + 消费者群组</h3><ol>
<li><em><strong>消费者从属于消费者群组</strong></em></li>
<li>一个消费者群组里的消费者订阅的是<strong>同一个主题</strong>，每个消费者接收主题的<strong>部分分区</strong>的消息</li>
</ol>
<h4 id="消费者横向扩展"><a href="#消费者横向扩展" class="headerlink" title="消费者横向扩展"></a>消费者横向扩展</h4><h5 id="1个消费者"><a href="#1个消费者" class="headerlink" title="1个消费者"></a>1个消费者</h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/definitive-guide/consumer_topic_1.png" width="400">

<ol>
<li>主题T1有4个分区，然后创建消费者C1，C1是消费者群组G1里唯一的消费者，C1订阅T1</li>
<li>消费者C1将接收主题T1的<strong>全部</strong>4个分区的消息</li>
</ol>
<span id="more"></span>

<h5 id="2个消费者"><a href="#2个消费者" class="headerlink" title="2个消费者"></a>2个消费者</h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/definitive-guide/consumer_topic_2.png" width="400">

<ol>
<li>如果群组G1新增一个消费者C2，那么每个消费者将<strong>分别从两个分区接收消息</strong></li>
<li>假设C1接收分区0和分区2的消息，C2接收分区1和分区3的消息</li>
</ol>
<h5 id="4个消费者"><a href="#4个消费者" class="headerlink" title="4个消费者"></a>4个消费者</h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/definitive-guide/consumer_topic_3.png" width="400">
如果群组G1有4个消费者，那么每个消费者可以分配到一个分区

<h5 id="5个消费者"><a href="#5个消费者" class="headerlink" title="5个消费者"></a>5个消费者</h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/definitive-guide/consumer_topic_4.png" width="400">
如果群组G1有5个消费者，_**消费者数量超过主题的分区数量**_，那么有1个消费者就会被**闲置**，不会接收到任何消息

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol>
<li>往群组里增加消费者是<strong>横向伸缩消费能力</strong>的主要方式</li>
<li>消费者经常会做一些<strong>高延迟</strong>的操作，比如把数据写到数据库或HDFS，或者使用数据进行比较耗时的计算</li>
<li>有必要<strong>为主题创建大量的分区</strong>，在负载增长时可以加入更多的消费者，<strong>减少消息堆积</strong><ul>
<li>不要让<strong>消费者的数量超过主题分区的数量</strong>，多余的消费者只会被<strong>闲置</strong></li>
</ul>
</li>
</ol>
<h4 id="消费者群组横向扩展"><a href="#消费者群组横向扩展" class="headerlink" title="消费者群组横向扩展"></a>消费者群组横向扩展</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kafka-1253868755.cos.ap-guangzhou.myqcloud.com/definitive-guide/consumer_topic_5.png" width="400">

<ol>
<li>Kafka设计的主要目标之一，就是要让Kafka主题里的数据能够满足企业各种应用场景（<strong>不同的消费者群组</strong>）的需求</li>
<li>在这些场景里，每个应用程序可以获取到<strong>所有的消息</strong>，而不只是其中的一部分</li>
<li>只要保证每个应用程序有自己的消费者群组，就可以让它们获取到主题所有的消息</li>
<li>不同于传统的消息系统，_<strong>横向伸缩Kafka消费者和消费者群组并不会对性能造成负面影响</strong>_</li>
</ol>
<h3 id="消费者群组-分区再均衡"><a href="#消费者群组-分区再均衡" class="headerlink" title="消费者群组 + 分区再均衡"></a>消费者群组 + 分区再均衡</h3><h4 id="分区再均衡"><a href="#分区再均衡" class="headerlink" title="分区再均衡"></a>分区再均衡</h4><ol>
<li>分区再均衡：_<strong>分区的所有权从一个消费者转移到另一个消费者</strong>_</li>
<li>分区再均衡非常重要，它为消费者群组带来了<strong>高可用性</strong>和<strong>伸缩性</strong>（可以放心地添加或移除消费者）</li>
<li>在分区再均衡期间，_<strong>消费者无法读取消息</strong>_，造成整个群组在一小段时间内<strong>不可用</strong></li>
<li>当分区被<strong>重新分配</strong>给另一个消费者时，消费者<strong>当前的读取状态</strong>会<strong>丢失</strong><ul>
<li>它有可能需要去<strong>刷新缓存</strong>，在它重新恢复状态之前会<strong>拖慢应用程序</strong></li>
</ul>
</li>
</ol>
<h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h4><ol>
<li>消费者通过向被指派为<strong>群组协调器</strong>的Broker发送<strong>心跳</strong><ul>
<li>目的<ul>
<li>维持它们_<strong>和群组的从属关系</strong>_</li>
<li>维持它们_<strong>对分区的所有权关系</strong>_</li>
</ul>
</li>
<li><strong>不同的群组可以有不同的协调器</strong></li>
</ul>
</li>
<li>只要消费者以<strong>正常的时间间隔</strong>发送心跳，就被认为是<strong>活跃</strong>的，说明它还在读取分区里的消息</li>
<li>消费者发送心跳的时机<ul>
<li><strong>轮询消息</strong>（为了获取消息）</li>
<li><strong>提交偏移量</strong></li>
</ul>
</li>
<li>如果消费者停止发送心跳的时间<strong>足够长</strong>，会话就会过期，群组协调器认为它已经<strong>死亡</strong>，就会触发一次<strong>再均衡</strong></li>
<li>如果一个消费者发生崩溃，并停止读取消息，群组协调器会等待几秒钟，确认它死亡了才会触发再均衡<ul>
<li>在这几秒的时间内，死掉的消费者不会读取分区里的消息</li>
</ul>
</li>
<li>在清理消费者时，消费者会<strong>通知</strong>群组协调器它<strong>将要离开群组</strong>，群组协调器会<strong>立即</strong>触发一次<strong>再均衡</strong>，尽量<strong>降低处理停顿</strong></li>
</ol>
<h4 id="分配分区"><a href="#分配分区" class="headerlink" title="分配分区"></a>分配分区</h4><ol>
<li>当消费者要加入消费者群组时，它会向<strong>群组协调器</strong>发送一个<code>JoinGroup</code>的请求，<strong>第一个</strong>加入群组的消费者将成为<strong>群主</strong></li>
<li><strong>群主</strong>（消费者）从<strong>群组协调器</strong>（Broker）那里获得<strong>成员列表</strong>（消费者）<ul>
<li>列表中包含了<strong>最近发送过心跳的消费者</strong>，它们被认为是<strong>活跃</strong>的</li>
<li><em><strong>群主负责给每个成员（消费者）分配分区</strong></em></li>
<li>实现<code>PartitionAssignor</code>接口的类来决定哪些分区应该被分配给哪个消费者</li>
</ul>
</li>
<li><strong>群主</strong>（消费者）分配分区完毕后，把<strong>分区的分配情况</strong>发送给<strong>群组协调器</strong>（Broker）<ul>
<li><strong>群组协调器</strong>（Broker）再把这些信息发送给<strong>所有的消费者</strong></li>
<li><em><strong>每个消费者只能看到自己的分配信息，只有群主知道消费者群组里所有消费者的分配信息</strong></em></li>
</ul>
</li>
<li>这个过程会在每次<strong>再均衡</strong>时重复发生</li>
</ol>
<h2 id="创建消费者"><a href="#创建消费者" class="headerlink" title="创建消费者"></a>创建消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">properties.put(<span class="string">&quot;group.id&quot;</span>, GROUP_ID);</span><br><span class="line">properties.put(<span class="string">&quot;key.deserializer&quot;</span>, StringDeserializer.class.getName());</span><br><span class="line">properties.put(<span class="string">&quot;value.deserializer&quot;</span>, StringDeserializer.class.getName());</span><br><span class="line">Consumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(properties);</span><br></pre></td></tr></table></figure>

<h2 id="订阅主题"><a href="#订阅主题" class="headerlink" title="订阅主题"></a>订阅主题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅主题</span></span><br><span class="line"><span class="comment">// 支持正则表达式：如果创建新主题，并且主题的名字与正则表达式匹配，</span></span><br><span class="line"><span class="comment">//              就会触发一次再均衡，消费者就能读取新添加的主题</span></span><br><span class="line"><span class="comment">// consumer.subscribe(&quot;test.*&quot;);</span></span><br><span class="line">consumer.subscribe(Collections.singletonList(TOPIC));</span><br></pre></td></tr></table></figure>

<h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><ol>
<li>消息轮询是消费者API的核心，通过一个简单的轮询向服务器请求数据</li>
<li>一旦消费者订阅了主题，轮询就会处理<strong>所有的细节</strong><ul>
<li><strong>群组协调</strong>、<strong>分区再均衡</strong>、<strong>发送心跳</strong>、<strong>获取数据</strong></li>
</ul>
</li>
<li>线程安全<ul>
<li>在同一个群组里，无法让一个线程运行多个消费者，也无法让多个线程安全地共享一个消费者</li>
<li>按照规则，_<strong>一个消费者使用一个线程</strong>_</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 消费者必须持续对Kafka进行轮询，否则会被认为已经死亡，它的分区就会被移交给群组里的其它消费者</span></span><br><span class="line">        <span class="comment">// 在消费者的缓冲区里没有可用数据时会发生阻塞</span></span><br><span class="line">        <span class="comment">// 返回一个记录列表，每条记录包含</span></span><br><span class="line">        <span class="comment">//  1. 记录所属主题的信息</span></span><br><span class="line">        <span class="comment">//  2. 记录所在分区的信息</span></span><br><span class="line">        <span class="comment">//  3. 记录在分区里的偏移量</span></span><br><span class="line">        <span class="comment">//  4. 记录的键值对</span></span><br><span class="line">        <span class="comment">// timeout参数指定多久之后可以返回，不管有没有可用的数据，0会立即返回</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">        records.forEach(record -&gt; log.info(<span class="string">&quot;topic=&#123;&#125;, partition=&#123;&#125;, offset=&#123;&#125;, key=&#123;&#125;, value=&#123;&#125;&quot;</span>,</span><br><span class="line">                record.topic(), record.partition(), record.offset(), record.key(), record.value()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 网络连接和Socket也会随之关闭</span></span><br><span class="line">    <span class="comment">// 并且立即触发一次再均衡，而不是等待群组协调器发现它不再发送心跳并认定它已死亡</span></span><br><span class="line">    <span class="comment">//  因为那样需要更长的时间，导致整个群组在一段时间内无法读取消息</span></span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消费者的配置"><a href="#消费者的配置" class="headerlink" title="消费者的配置"></a>消费者的配置</h2><h3 id="fetch-min-bytes"><a href="#fetch-min-bytes" class="headerlink" title="fetch.min.bytes"></a>fetch.min.bytes</h3><ol>
<li>该参数指定了消费者<strong>单个数据请求</strong>的最小字节数，默认值为<code>1</code></li>
<li>Broker在收到消费者的数据请求时<ul>
<li>如果可用的数据量小于<code>fetch.min.bytes</code>指定的大小，那么它会等到有足够的可用数据时才会返回给消费者</li>
<li>这样可以降低消费者和Broker的工作负载，因为在主题不是很活跃的时候，就不需要来回处理消息</li>
</ul>
</li>
</ol>
<h3 id="fetch-max-wait-ms"><a href="#fetch-max-wait-ms" class="headerlink" title="fetch.max.wait.ms"></a>fetch.max.wait.ms</h3><ol>
<li>如果<code>fetch.max.wait.ms</code>（默认值为500）被设为100ms，并且<code>fetch.min.bytes</code>被设为1MB</li>
<li>那么Kafka在收到消费者的请求后，要么返回1MB数据，要么在100ms后返回所有可用的数据，<strong>看哪个条件先得到满足</strong></li>
</ol>
<h3 id="max-partition-fetch-bytes"><a href="#max-partition-fetch-bytes" class="headerlink" title="max.partition.fetch.bytes"></a>max.partition.fetch.bytes</h3><ol>
<li>该参数指定了服务器从<strong>每个分区</strong>里返回给消费者的最大字节数，默认1MB<ul>
<li><code>Consumer.poll()</code>方法从<strong>每个分区</strong>里返回的数据不能超过<code>max.partition.fetch.bytes</code></li>
<li>如果单次<code>poll()</code>返回的数据太多，消费者需要更多时间来处理<ul>
<li>可能无法及时地进行下一次<strong>轮询</strong>（发送<strong>心跳</strong>）来避免<strong>会话过期</strong>，<strong>触发再平衡</strong></li>
<li>减少<code>max.partition.fetch.bytes</code>的值</li>
<li>或者<strong>延长会话过期时间</strong></li>
</ul>
</li>
</ul>
</li>
<li>如果主题有20个分区和5个消费者，那么每个消费者需要至少4MB的可用内存来接收记录<ul>
<li>在为消费者分配内存时，可以适当地多分配些</li>
<li>因为如果消费者群组里有消费者发生崩溃，剩下的消费者需要处理更多的分区</li>
</ul>
</li>
<li><code>max.partition.fetch.bytes</code>必须比<code>message.max.bytes</code>（Broker能够接收到最大消息的字节数）大<ul>
<li>否着消费者可能<strong>无法读取</strong>这些<strong>大消息</strong>，导致<strong>消费者一直挂起重试</strong></li>
</ul>
</li>
</ol>
<h3 id="session-timeout-ms-heartbeat-interval-ms"><a href="#session-timeout-ms-heartbeat-interval-ms" class="headerlink" title="session.timeout.ms + heartbeat.interval.ms"></a>session.timeout.ms + heartbeat.interval.ms</h3><ol>
<li><code>session.timeout.ms</code>指定了<strong>消费者在被认为死亡之前可以与服务器断开连接的时间</strong>，默认值为10000<ul>
<li>如果消费者没有在<code>session.timeout.ms</code>指定的时间内发送<strong>心跳</strong>给在<strong>群组协调器</strong>（Broker）</li>
<li>就会被认为已经死亡，群组协调器就会触发<strong>再均衡</strong></li>
</ul>
</li>
<li><code>heartbeat.interval.ms</code>指定了<code>poll()</code>方法向群组协调器<strong>发送心跳的频率</strong>，默认值为3000<ul>
<li>而<code>session.timeout.ms</code>指定了消费者<strong>可以多久不发心跳</strong></li>
</ul>
</li>
<li><code>heartbeat.interval.ms</code>必须比<code>session.timeout.ms</code>小，一般是<code>session.timeout.ms</code>的<strong>1&#x2F;3</strong></li>
<li>如果把<code>session.timeout.ms</code>值设置得<strong>比默认值小</strong>，可以<strong>更快地检测和恢复崩溃的节点</strong><ul>
<li>不过长时间的轮询或者GC可能会导致<strong>非预期的再均衡</strong></li>
</ul>
</li>
<li>如果把<code>session.timeout.ms</code>值设置得比默认值大，<strong>可以减少意外的再均衡</strong><ul>
<li>不过检测节点崩溃需要更长的时间</li>
</ul>
</li>
</ol>
<h3 id="auto-offset-reset"><a href="#auto-offset-reset" class="headerlink" title="auto.offset.reset"></a>auto.offset.reset</h3><ol>
<li>该参数指定了消费者在下列情况下该如何处理<ul>
<li>读取一个<strong>没有偏移量</strong>的分区（新加入消费者，还没有该消费者的消费记录）</li>
<li><strong>偏移量无效</strong>（消费者长时间失效，包含偏移量的记录已经过时并被删除）</li>
</ul>
</li>
<li>默认值是<strong>latest</strong>：消费者从<strong>最新</strong>的记录开始读取数据</li>
<li><strong>earliest</strong>：消费者从<strong>起始位置</strong>读取分区的记录</li>
</ol>
<h3 id="enable-auto-commit-auto-commit-interval-ms"><a href="#enable-auto-commit-auto-commit-interval-ms" class="headerlink" title="enable.auto.commit + auto.commit.interval.ms"></a>enable.auto.commit + auto.commit.interval.ms</h3><ol>
<li><code>enable.auto.commit</code>指定了消费者是否<strong>自动提交偏移量</strong>，默认值是true<ul>
<li>可能出现<strong>重复数据</strong>和<strong>数据丢失</strong></li>
</ul>
</li>
<li><code>auto.commit.interval.ms</code>指定提交的<strong>频率</strong>，默认值为5000</li>
</ol>
<h3 id="partition-assignment-strategy"><a href="#partition-assignment-strategy" class="headerlink" title="partition.assignment.strategy"></a>partition.assignment.strategy</h3><ol>
<li>分区会被分配给消费群组里的消费者的策略</li>
<li><code>Range</code>：把主题的若干<strong>连续</strong>的分区分配给消费者，默认值</li>
<li><code>RoundRobin</code>：把主题的所有分区<strong>逐个</strong>分配给消费者</li>
</ol>
<h3 id="client-id"><a href="#client-id" class="headerlink" title="client.id"></a>client.id</h3><ol>
<li>任意字符串，Broker用它来标识从客户端发过来的消息</li>
<li>通常被用在日志、度量指标和配额里</li>
</ol>
<h3 id="max-poll-records"><a href="#max-poll-records" class="headerlink" title="max.poll.records"></a>max.poll.records</h3><ol>
<li>该参数用于控制单次调用<code>poll()</code>方法能够返回的消息数量，默认值为500</li>
</ol>
<h3 id="receive-buffer-bytes-send-buffer-bytes"><a href="#receive-buffer-bytes-send-buffer-bytes" class="headerlink" title="receive.buffer.bytes + send.buffer.bytes"></a>receive.buffer.bytes + send.buffer.bytes</h3><ol>
<li>设置socket在<strong>读写数据</strong>时用到的<strong>TCP缓冲区</strong><ul>
<li>如果为**-1<strong>，就使用</strong>操作系统的默认值**</li>
<li><code>receive.buffer.bytes</code>的默认值为<code>32KB</code></li>
<li><code>send.buffer.bytes</code>的默认值为<code>128KB</code></li>
</ul>
</li>
<li>如果生产者或消费者与Broker处于不同的数据中心内，可以适当增大这些值</li>
</ol>
<h2 id="提交-偏移量"><a href="#提交-偏移量" class="headerlink" title="提交 + 偏移量"></a>提交 + 偏移量</h2><ol>
<li>每次调用<code>poll()</code>方法，总是返回由生产者写入Kafka但还没有被消费者读取过的记录</li>
<li>Kakfa不像其它JMS队列那样，_<strong>Kafka不需要得到消费者的确认</strong>_</li>
<li>消费者可以使用Kafka来追踪消息在分区里的位置（偏移量）</li>
<li>把<strong>更新分区当前位置</strong>的操作叫作<strong>提交</strong><ul>
<li>消费者往一个叫作<code>__consumer_offsets</code>的特殊主题发送消息，消息里包含_<strong>每个分区的偏移量</strong>_</li>
<li>如果<strong>消费者发生崩溃</strong>或者有<strong>新的消费者加入群组</strong>，就会触发<strong>再均衡</strong></li>
<li>完成再均衡之后，每个消费者可能<strong>分配到新的分区</strong><ul>
<li>为了能继续之前的工作，消费者需要读取<strong>每个分区最后一次提交的偏移量</strong>，然后从偏移量指定的位置继续处理</li>
</ul>
</li>
</ul>
</li>
<li>偏移量不相同<ul>
<li>如果提交的偏移量 <strong>小于</strong> 客户端处理的最后一个消息的偏移量<ul>
<li>那么处于<strong>两个偏移量之间的消息</strong>就会被_<strong>重复处理</strong>_</li>
</ul>
</li>
<li>如果提交的偏移量 <strong>大于</strong> 客户端处理的最后一个消息的偏移量<ul>
<li>那么处于<strong>两个偏移量之间的消息</strong>就会_<strong>丢失</strong>_</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><ol>
<li>自动提交是基于<strong>时间间隔</strong></li>
<li>如果<code>enable.auto.commit</code>为true，那么每过<code>auto.commit.interval.ms</code>（默认5s）<ul>
<li>消费者就会自动把从<code>poll()</code>方法接收到的<strong>最大偏移量</strong>提交上去，_<strong>不论客户端是否真的处理完</strong>_</li>
</ul>
</li>
<li>自动提交也是在<strong>轮询</strong>里进行，消费者<strong>每次轮询</strong>时会<strong>检查是否该提交偏移量</strong><ul>
<li>如果是，那就会提交<code>poll()</code>返回的<strong>最大偏移量</strong></li>
</ul>
</li>
</ol>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li><em><strong>消息重复处理</strong></em><ul>
<li>假设时刻<code>T</code>自动提交，在时刻<code>T+3</code>发生了再均衡，还没到时刻<code>T+5</code><ul>
<li><em>客户端已经处理的部分消息没有被提交</em></li>
</ul>
</li>
<li>再均衡之后，消费者还是会从最后一次提交的偏移量位置（时刻<code>T</code>）开始读取消息，消息会被重复处理</li>
</ul>
</li>
<li><em><strong>消息丢失</strong></em><ul>
<li>假设时刻<code>T</code>自动提交，执行<code>poll()</code>拉回100条消息，在时刻<code>T+5</code>会再次提交</li>
<li>但在时刻<code>T+5</code>，客户端只处理完了90条消息，在自动提交完成之后的那一刻该客户端崩溃，消息丢失</li>
</ul>
</li>
<li>每次调用轮询方法都会把上一次调用<code>poll()</code>返回的<strong>最大偏移量</strong>提交上去，_<strong>并不关心哪些消息已经被处理过了</strong>_<ul>
<li>所以在再次调用轮询之前最好确保<strong>所有应该处理的消息</strong>都已经处理完毕</li>
</ul>
</li>
</ol>
<h3 id="同步提交"><a href="#同步提交" class="headerlink" title="同步提交"></a>同步提交</h3><ol>
<li><code>enable.auto.commit=false</code>，让应用程序决定何时提交偏移量</li>
<li>使用<code>commitAsync()</code>提交偏移量<strong>最简单也最可靠</strong><ul>
<li>提交由<code>poll()</code>方法返回的<strong>最大偏移量</strong>，提交成功后立马返回，如果提交失败就会抛出异常</li>
</ul>
</li>
<li>如果发生<strong>再均衡</strong>，消息会被_<strong>重复处理</strong>_</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Collections.singletonList(TOPIC));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取最新偏移量</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">        records.forEach(record -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;topic=&#123;&#125;, partition=&#123;&#125;, offset=&#123;&#125;, key=&#123;&#125;, value=&#123;&#125;&quot;</span>,</span><br><span class="line">                    record.topic(), record.partition(), record.offset(), record.key(), record.value());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 同步提交当前偏移量</span></span><br><span class="line">        consumer.commitAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步提交"><a href="#异步提交" class="headerlink" title="异步提交"></a>异步提交</h3><ol>
<li><strong>同步提交</strong>，在Broker对提交请求作出响应之前，应用程序会一直<strong>阻塞</strong>，_<strong>限制应用程序的吞吐量</strong>_<ul>
<li>可以通过<strong>降低提交频率</strong>来<strong>提升吞吐量</strong>，但如果发生再均衡，会增加重复消息的数量</li>
</ul>
</li>
<li>在<strong>成功提交</strong>或碰到<strong>无法恢复的错误</strong>之前，<code>commitSync()</code>会<strong>一直重试</strong>，但是<code>commitAsync()</code>不会<ul>
<li>不进行重试的原因：_<strong>在它收到服务器响应的时候，可能有一个更大的偏移量已经提交成功</strong>_</li>
</ul>
</li>
<li><code>commitAsync()</code>支持<strong>回调</strong>，在Broker作出响应时会执行回调（通常用于记录提交错误或生成度量指标）<ul>
<li>如果用<strong>回调</strong>来进行<strong>重试</strong>，一定要注意_<strong>提交的顺序</strong>_</li>
<li>使用一个<strong>单调递增的序列号</strong>来维护<strong>异步提交的顺序</strong></li>
<li>在每次<strong>提交偏移量之后</strong>或者在<strong>回调里提交偏移量时</strong>递增序列号</li>
<li>在进行重试前，先检查<strong>回调的序列号</strong>和<strong>即将提交的偏移量</strong>是否相等<ul>
<li>如果<strong>相等</strong>，说明没有新的提交，那么可以安全地进行<strong>重试</strong></li>
<li>如果<strong>回调序列号比较大</strong>，说明有一个新的提交已经发送出去了，应该<strong>停止重试</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Collections.singletonList(TOPIC));</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;topic=&#123;&#125;, partition=&#123;&#125;, offset=&#123;&#125;, key=&#123;&#125;, value=&#123;&#125;&quot;</span>,</span><br><span class="line">                record.topic(), record.partition(), record.offset(),</span><br><span class="line">                record.key(), record.value());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步提交</span></span><br><span class="line">    consumer.commitAsync((offsets, exception) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Commit failed for offsets &quot;</span> + offsets, exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合提交（同步-异步）"><a href="#组合提交（同步-异步）" class="headerlink" title="组合提交（同步+异步）"></a>组合提交（同步+异步）</h3><ol>
<li>一般情况下，偶尔出现的提交失败，不进行重试不会有太大问题</li>
<li>如果这是发生在<strong>关闭消费者</strong>或者<strong>再均衡前</strong>的<strong>最后一次提交</strong>，那么就要_<strong>确保能够提交成功</strong>_</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Collections.singletonList(TOPIC));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;topic=&#123;&#125;, partition=&#123;&#125;, offset=&#123;&#125;, key=&#123;&#125;, value=&#123;&#125;&quot;</span>,</span><br><span class="line">                    record.topic(), record.partition(), record.offset(),</span><br><span class="line">                    record.key(), record.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异步提交，速度更快，如果这次提交失败，下一次提交很有可能会成功</span></span><br><span class="line">        consumer.commitAsync((offsets, exception) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Commit failed for offsets &quot;</span> + offsets, exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Unexpected error&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 一直重试，直到提交成功或者发生无法恢复的错误</span></span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果直接关闭消费者，就没有所谓的下一次提交了</span></span><br><span class="line">        consumer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="提交特定的偏移量"><a href="#提交特定的偏移量" class="headerlink" title="提交特定的偏移量"></a>提交特定的偏移量</h3><ol>
<li>提交偏移量的频率和处理消息批次的频率是一样的</li>
<li><code>commitSync()</code>和<code>commitAsync()</code>，只会提交<strong>最后一个偏移</strong>，而此时该批次里的部分消息可能还没处理</li>
<li>如果需要提交特定的偏移量，需要<strong>跟踪所有分区的偏移量</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">consumer.subscribe(Collections.singletonList(TOPIC));</span><br><span class="line"><span class="comment">// 用于追踪偏移量的Map</span></span><br><span class="line">Map&lt;TopicPartition, OffsetAndMetadata&gt; currentOffsets = Maps.newHashMap();</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;topic=&#123;&#125;, partition=&#123;&#125;, offset=&#123;&#125;, key=&#123;&#125;, value=&#123;&#125;&quot;</span>,</span><br><span class="line">                record.topic(), record.partition(), record.offset(), record.key(), record.value());</span><br><span class="line">        <span class="comment">// 在读取每条记录后，使用期望处理的下一条记录的偏移量更新map里的偏移量</span></span><br><span class="line">        <span class="comment">// 下一次就从这里开始读取消息</span></span><br><span class="line">        <span class="type">TopicPartition</span> <span class="variable">topicPartition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), record.partition());</span><br><span class="line">        <span class="type">OffsetAndMetadata</span> <span class="variable">offsetAndMetadata</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OffsetAndMetadata</span>(record.offset() + <span class="number">1</span>, <span class="string">&quot;no metadata&quot;</span>);</span><br><span class="line">        currentOffsets.put(topicPartition, offsetAndMetadata);</span><br><span class="line">        <span class="keyword">if</span> (count++ % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 每处理1000条记录就提交一次偏移量</span></span><br><span class="line">            <span class="comment">// 提交特定偏移量时，仍然要处理可能发生的错误（虽然这里的OffsetCommitCallback虽然为null）</span></span><br><span class="line">            consumer.commitAsync(currentOffsets, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="再均衡监听器"><a href="#再均衡监听器" class="headerlink" title="再均衡监听器"></a>再均衡监听器</h2><ol>
<li>消费者在<strong>退出消费者群组</strong>和进行<strong>分区再均衡</strong>之前，会做一些清理工作<ul>
<li>在消费者<strong>失去对一个分区的所有权之前</strong>提交<strong>最后一个已处理</strong>记录的<strong>偏移量</strong></li>
<li>如果消费者准备了一个缓冲区用于处理偶发的事件，那么在失去分区所有权之前，需要处理在缓冲区累积下来的记录</li>
<li>关闭文件句柄，数据库连接</li>
</ul>
</li>
<li>在为消费者<strong>分配新分区</strong>或者<strong>移除旧分区</strong>时，可以通过消费者API执行一些动作<ul>
<li>在调用<code>subscribe()</code>方法传进去一个<code>ConsumerRebalanceListener</code>实例</li>
<li><code>onPartitionsRevoked</code><ul>
<li>在<strong>消费者停止读取消息之后</strong>和<strong>再均衡开始之前</strong>被调用</li>
<li>如果在这里提交偏移量，下一个接管分区的消费者就知道该从哪里开始读取</li>
</ul>
</li>
<li><code>onPartitionsAssigned</code><ul>
<li>在<strong>重新分配分区之后</strong>和<strong>消费者开始读取之前</strong>被调用</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;TopicPartition, OffsetAndMetadata&gt; currentOffsets = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HandleRebalance</span> <span class="keyword">implements</span> <span class="title class_">ConsumerRebalanceListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果发生再均衡，需要提交的是最近处理过的偏移量，而不是批次中还在处理的最后一个偏移量</span></span><br><span class="line">        consumer.commitSync(currentOffsets);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    consumer.subscribe(Collections.singletonList(<span class="string">&quot;CustomerCountry&quot;</span>), <span class="keyword">new</span> <span class="title class_">HandleRebalance</span>());</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;topic=&#123;&#125;, partition=&#123;&#125;, offset=&#123;&#125;, key=&#123;&#125;, value=&#123;&#125;&quot;</span>,</span><br><span class="line">                    record.topic(), record.partition(), record.offset(),</span><br><span class="line">                    record.key(), record.value());</span><br><span class="line">            <span class="comment">// 在读取每条记录后，使用期望处理的下一条记录的偏移量更新map里的偏移量</span></span><br><span class="line">            <span class="comment">// 下一次就从这里开始读取消息</span></span><br><span class="line">            currentOffsets.put(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), record.partition()),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">OffsetAndMetadata</span>(record.offset() + <span class="number">1</span>, <span class="string">&quot;no metadata&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.commitAsync(currentOffsets, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;</span><br><span class="line">    <span class="comment">// 忽略异常，正在关闭消费者</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Unexpected error&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        consumer.commitSync(currentOffsets);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        consumer.close();</span><br><span class="line">        log.info(<span class="string">&quot;Close consumer successfully!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从特定偏移量开始处理记录"><a href="#从特定偏移量开始处理记录" class="headerlink" title="从特定偏移量开始处理记录"></a>从特定偏移量开始处理记录</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.kafka.clients.consumer.Consumer</span></span><br><span class="line"><span class="comment">// 从分区的起始位置开始读取消息</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">seekToBeginning</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span>;</span><br><span class="line"><span class="comment">// 直接跳到分区的末尾开始读取消息</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">seekToEnd</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span>;</span><br><span class="line"><span class="comment">// 直接跳到特定偏移量</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">seek</span><span class="params">(TopicPartition partition, <span class="type">long</span> offset)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">commitDbTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getOffsetFromDB</span><span class="params">(TopicPartition partition)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">storeOffsetInDb</span><span class="params">(String topic, <span class="type">int</span> partition, <span class="type">long</span> offset)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">storeRecordInDb</span><span class="params">(ConsumerRecord&lt;String, String&gt; record)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processRecord</span><span class="params">(ConsumerRecord&lt;String, String&gt; record)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seekTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SaveOffsetOnRebalance</span> <span class="keyword">implements</span> <span class="title class_">ConsumerRebalanceListener</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> &#123;</span><br><span class="line">            commitDbTransaction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> &#123;</span><br><span class="line">            partitions.forEach(partition -&gt; consumer.seek(partition, getOffsetFromDB(partition)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    consumer.subscribe(Collections.singletonList(TOPIC), <span class="keyword">new</span> <span class="title class_">SaveOffsetOnRebalance</span>());</span><br><span class="line">    consumer.assignment().forEach(partition -&gt; consumer.seek(partition, getOffsetFromDB(partition)));</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">        records.forEach(record -&gt; &#123;</span><br><span class="line">            processRecord(record);</span><br><span class="line">            <span class="comment">// 同一个事务</span></span><br><span class="line">            storeRecordInDb(record);</span><br><span class="line">            storeOffsetInDb(record.topic(), record.partition(), record.offset());</span><br><span class="line">        &#125;);</span><br><span class="line">        commitDbTransaction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ShutdownHook运行在单独的线程里，所以退出循环最安全的方式是调用wakeup()</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// wakeup()是消费者唯一一个可以从其他线程里安全调用的方法</span></span><br><span class="line">        <span class="comment">// 调用wakeup()可以退出poll()，并抛出WakeupException</span></span><br><span class="line">        <span class="comment">//  WakeupException不需要处理，这只是跳出循环的一种方式</span></span><br><span class="line">        <span class="comment">// 在退出线程之前调用close()是很有必要的</span></span><br><span class="line">        <span class="comment">//  close()方法会提交任何还没有提交的东西，并向群组协调器发送消息，告知自己要离开群组</span></span><br><span class="line">        <span class="comment">//  接下来就会触发再均衡，不需要等待会话超时</span></span><br><span class="line">        consumer.wakeup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 主线程</span></span><br><span class="line">            join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 循环，直到按下CTRL+C，关闭的钩子会在退出时进行清理</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">        records.forEach(record -&gt; &#123;</span><br><span class="line">            <span class="comment">// process</span></span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.assignment().forEach(partition -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.commitSync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (WakeupException e) &#123;</span><br><span class="line">    <span class="comment">// ignore</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 退出之前，确保彻底关闭了消费者</span></span><br><span class="line">    consumer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反序列化器"><a href="#反序列化器" class="headerlink" title="反序列化器"></a>反序列化器</h2><ol>
<li>对于开发者而言<ul>
<li>必须明确写入主题的消息使用的是哪一种序列化器</li>
<li>并确保每个主题里只包含能够被反序列化器解析的数据</li>
</ul>
</li>
</ol>
<h3 id="自定义序列化器"><a href="#自定义序列化器" class="headerlink" title="自定义序列化器"></a>自定义序列化器</h3><ol>
<li>不推荐使用<strong>自定义序列化器</strong>和<strong>自定义反序列化器</strong>，它们把生产者和消费者<strong>耦合</strong>在一起，很<strong>脆弱</strong>，容易出错</li>
<li>推荐使用标准的消息格式，如<code>JSON</code>、<code>Thrift</code>、<code>Protobuf</code>和<code>Avro</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;group.id&quot;</span>, GROUP_ID);</span><br><span class="line">props.put(<span class="string">&quot;key.deserializer&quot;</span>, StringDeserializer.class.getName());</span><br><span class="line"><span class="comment">// 自定义的反序列化器</span></span><br><span class="line">props.put(<span class="string">&quot;value.deserializer&quot;</span>, CustomerDeserializer.class);</span><br><span class="line">Consumer&lt;Object, Object&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(props);</span><br><span class="line">consumer.subscribe(Collections.singletonList(TOPIC));</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;Object, Object&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    records.forEach(record -&gt; &#123;</span><br><span class="line">        <span class="comment">// process</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomerDeserializer</span> <span class="keyword">implements</span> <span class="title class_">Deserializer</span>&lt;Customer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; configs, <span class="type">boolean</span> isKey)</span> &#123;</span><br><span class="line">        <span class="comment">// 不做任何配置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Customer <span class="title function_">deserialize</span><span class="params">(String topic, <span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (data.length &lt; <span class="number">8</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializationException</span>(<span class="string">&quot;Size of received is shorter than expected&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(data);</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> buffer.getInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">nameSize</span> <span class="operator">=</span> buffer.getInt();</span><br><span class="line">            <span class="type">byte</span>[] nameBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[nameSize];</span><br><span class="line">            buffer.get(nameBytes);</span><br><span class="line">            <span class="type">String</span> <span class="variable">deserializedName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(nameBytes, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(id, deserializedName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// log</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="独立消费者"><a href="#独立消费者" class="headerlink" title="独立消费者"></a>独立消费者</h2><ol>
<li>场景<ul>
<li>只需要一个消费者从一个主题的<strong>所有分区</strong>或者某个<strong>特定分区</strong>读取数据</li>
<li>此时不再需要<strong>消费者群组</strong>和<strong>再均衡</strong></li>
<li>只需要把主题或者分区分配给消费者，然后开始读取消息并提交偏移量</li>
</ul>
</li>
<li>这时不再需要订阅主题，取而代之的是<strong>消费者为自己分配分区</strong></li>
<li>一个消费者可以<strong>订阅主题</strong>（并加入消费者群组），或者为自己<strong>分配分区</strong>，但这两个动作是<strong>互斥</strong>的</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向集群请求主题可用的分区，如果只读取特定分区，跳过这一步</span></span><br><span class="line">List&lt;PartitionInfo&gt; partitionInfoList = consumer.partitionsFor(TOPIC);</span><br><span class="line"><span class="keyword">if</span> (partitionInfoList != <span class="literal">null</span>) &#123;</span><br><span class="line">    List&lt;TopicPartition&gt; partitions = Lists.newArrayList();</span><br><span class="line">    partitionInfoList.forEach(partitionInfo -&gt; &#123;</span><br><span class="line">        partitions.add(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(partitionInfo.topic(), partitionInfo.partition()));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 知道哪些分区后，调用assign()方法</span></span><br><span class="line">    <span class="comment">// 不会发生再均衡，也不需要手动查找分区</span></span><br><span class="line">    <span class="comment">// 但是如果主题增加了新的分区，消费者并不会收到通知</span></span><br><span class="line">    <span class="comment">//  因此需要周期性地调用consumer.partitionsFor()来检查是否有新分区加入</span></span><br><span class="line">    <span class="comment">//  要么在添加新分区后重启应用程序</span></span><br><span class="line">    consumer.assign(partitions);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">    records.forEach(record -&gt; &#123;</span><br><span class="line">        <span class="comment">// process</span></span><br><span class="line">    &#125;);</span><br><span class="line">    consumer.commitSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- indicate-the-source -->
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://blog.zhongmingmao.top">zhongmingmao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://blog.zhongmingmao.top/2018/10/18/kafka-consume/">https://blog.zhongmingmao.top/2018/10/18/kafka-consume/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/middleware/">Middleware</a><a class="post-meta__tags" href="/tags/mq/">MQ</a><a class="post-meta__tags" href="/tags/kafka/">Kafka</a><a class="post-meta__tags" href="/tags/stream/">Stream</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2018/12/14/jvm-basic-run/" title="JVM基础 -- 运行过程+运行效率"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-5.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">JVM基础 -- 运行过程+运行效率</div></div></a></div><div class="next-post pull-right"><a href="/2018/10/17/kafka-avro-bijection/" title="Kafka -- Avro + Twitter Bijection"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-23.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Kafka -- Avro + Twitter Bijection</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2019/09/30/kafka-tuning/" title="Kafka -- 调优"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-30</div><div class="title">Kafka -- 调优</div></div></a></div><div><a href="/2019/09/29/kafka-monitor/" title="Kafka -- 监控"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-21.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-29</div><div class="title">Kafka -- 监控</div></div></a></div><div><a href="/2019/09/28/kafka-admin-client/" title="Kafka -- KafkaAdminClient"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-28</div><div class="title">Kafka -- KafkaAdminClient</div></div></a></div><div><a href="/2019/09/27/kafka-shell/" title="Kafka -- 常用脚本"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-23.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-27</div><div class="title">Kafka -- 常用脚本</div></div></a></div><div><a href="/2019/09/26/kafka-reset-consumer-group-offset/" title="Kafka -- 重设消费者组位移"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-26</div><div class="title">Kafka -- 重设消费者组位移</div></div></a></div><div><a href="/2019/09/25/kafka-dynamic-config/" title="Kafka -- 动态配置"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-25</div><div class="title">Kafka -- 动态配置</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/z.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zhongmingmao</div><div class="author-info__description">Focus on Infrastructure.</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">633</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">189</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">80</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:zhongmingmao0625@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Things are always unexpected!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BE%A4%E7%BB%84"><span class="toc-number">1.1.</span> <span class="toc-text">消费者 + 消费者群组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%AA%E5%90%91%E6%89%A9%E5%B1%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">消费者横向扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1个消费者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">2个消费者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">4个消费者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E4%B8%AA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">5个消费者</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%BE%A4%E7%BB%84%E6%A8%AA%E5%90%91%E6%89%A9%E5%B1%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">消费者群组横向扩展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%BE%A4%E7%BB%84-%E5%88%86%E5%8C%BA%E5%86%8D%E5%9D%87%E8%A1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">消费者群组 + 分区再均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%86%8D%E5%9D%87%E8%A1%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">分区再均衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3"><span class="toc-number">1.2.2.</span> <span class="toc-text">心跳</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%88%86%E5%8C%BA"><span class="toc-number">1.2.3.</span> <span class="toc-text">分配分区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">2.</span> <span class="toc-text">创建消费者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E4%B8%BB%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">订阅主题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2"><span class="toc-number">4.</span> <span class="toc-text">轮询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">5.</span> <span class="toc-text">消费者的配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fetch-min-bytes"><span class="toc-number">5.1.</span> <span class="toc-text">fetch.min.bytes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fetch-max-wait-ms"><span class="toc-number">5.2.</span> <span class="toc-text">fetch.max.wait.ms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#max-partition-fetch-bytes"><span class="toc-number">5.3.</span> <span class="toc-text">max.partition.fetch.bytes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session-timeout-ms-heartbeat-interval-ms"><span class="toc-number">5.4.</span> <span class="toc-text">session.timeout.ms + heartbeat.interval.ms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#auto-offset-reset"><span class="toc-number">5.5.</span> <span class="toc-text">auto.offset.reset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enable-auto-commit-auto-commit-interval-ms"><span class="toc-number">5.6.</span> <span class="toc-text">enable.auto.commit + auto.commit.interval.ms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#partition-assignment-strategy"><span class="toc-number">5.7.</span> <span class="toc-text">partition.assignment.strategy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#client-id"><span class="toc-number">5.8.</span> <span class="toc-text">client.id</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#max-poll-records"><span class="toc-number">5.9.</span> <span class="toc-text">max.poll.records</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#receive-buffer-bytes-send-buffer-bytes"><span class="toc-number">5.10.</span> <span class="toc-text">receive.buffer.bytes + send.buffer.bytes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4-%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text">提交 + 偏移量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4"><span class="toc-number">6.1.</span> <span class="toc-text">自动提交</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.1.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%8F%90%E4%BA%A4"><span class="toc-number">6.2.</span> <span class="toc-text">同步提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%8F%90%E4%BA%A4"><span class="toc-number">6.3.</span> <span class="toc-text">异步提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%8F%90%E4%BA%A4%EF%BC%88%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">组合提交（同步+异步）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E7%89%B9%E5%AE%9A%E7%9A%84%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">6.5.</span> <span class="toc-text">提交特定的偏移量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E5%9D%87%E8%A1%A1%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">再均衡监听器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E7%89%B9%E5%AE%9A%E5%81%8F%E7%A7%BB%E9%87%8F%E5%BC%80%E5%A7%8B%E5%A4%84%E7%90%86%E8%AE%B0%E5%BD%95"><span class="toc-number">8.</span> <span class="toc-text">从特定偏移量开始处理记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%80%E5%87%BA"><span class="toc-number">9.</span> <span class="toc-text">退出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">反序列化器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8"><span class="toc-number">10.1.</span> <span class="toc-text">自定义序列化器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">11.</span> <span class="toc-text">独立消费者</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/15/new-java-feature-flow/" title="New Java Feature - Flow"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://java-feature-1253868755.cos.ap-guangzhou.myqcloud.com/java-flow.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="New Java Feature - Flow"/></a><div class="content"><a class="title" href="/2025/01/15/new-java-feature-flow/" title="New Java Feature - Flow">New Java Feature - Flow</a><time datetime="2025-01-14T16:06:25.000Z" title="Created 2025-01-15 00:06:25">2025-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/14/new-java-feature-error-code/" title="New Java Feature - Error Code"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://java-feature-1253868755.cos.ap-guangzhou.myqcloud.com/java-exception-recovery.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="New Java Feature - Error Code"/></a><div class="content"><a class="title" href="/2025/01/14/new-java-feature-error-code/" title="New Java Feature - Error Code">New Java Feature - Error Code</a><time datetime="2025-01-13T16:06:25.000Z" title="Created 2025-01-14 00:06:25">2025-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/13/new-java-feature-exception/" title="New Java Feature - Exception"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://java-feature-1253868755.cos.ap-guangzhou.myqcloud.com/java-feature-exception.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="New Java Feature - Exception"/></a><div class="content"><a class="title" href="/2025/01/13/new-java-feature-exception/" title="New Java Feature - Exception">New Java Feature - Exception</a><time datetime="2025-01-12T16:06:25.000Z" title="Created 2025-01-13 00:06:25">2025-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/12/new-java-feature-switch-matching/" title="New Java Feature - Switch Matching"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://java-feature-1253868755.cos.ap-guangzhou.myqcloud.com/image-20250804150004058.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="New Java Feature - Switch Matching"/></a><div class="content"><a class="title" href="/2025/01/12/new-java-feature-switch-matching/" title="New Java Feature - Switch Matching">New Java Feature - Switch Matching</a><time datetime="2025-01-11T16:06:25.000Z" title="Created 2025-01-12 00:06:25">2025-01-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/11/new-java-feature-switch-expression/" title="New Java Feature - Switch Expression"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://java-feature-1253868755.cos.ap-guangzhou.myqcloud.com/java-switch-expressions.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="New Java Feature - Switch Expression"/></a><div class="content"><a class="title" href="/2025/01/11/new-java-feature-switch-expression/" title="New Java Feature - Switch Expression">New Java Feature - Switch Expression</a><time datetime="2025-01-10T16:06:25.000Z" title="Created 2025-01-11 00:06:25">2025-01-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.pixabay.com/photo/2018/08/27/15/17/fishing-3635221_1280.png')"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2025 By zhongmingmao</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Life is like a box of chocolates. You can't know what you'll eat until you open it.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>