<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM基础 -- 垃圾回收基础 | ByteCoding</title><meta name="author" content="zhongmingmao"><meta name="copyright" content="zhongmingmao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="判定对象存亡垃圾回收标记的是非垃圾 引用计数法 为每个对象添加一个引用计数器，用来统计指向该对象的引用个数 如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器+1 如果指向某一对象的引用，被赋值为其他值，那么该对象的引用计数器-1   一旦某个对象的引用计数器为0，说明对象已经死亡 缺点 额外的空间来存储计数器 + 繁琐的更新操作 无法处理循环引用的场景，造成内存泄露">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM基础 -- 垃圾回收基础">
<meta property="og:url" content="https://blog.zhongmingmao.top/2018/12/26/jvm-basic-gc/index.html">
<meta property="og:site_name" content="ByteCoding">
<meta property="og:description" content="判定对象存亡垃圾回收标记的是非垃圾 引用计数法 为每个对象添加一个引用计数器，用来统计指向该对象的引用个数 如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器+1 如果指向某一对象的引用，被赋值为其他值，那么该对象的引用计数器-1   一旦某个对象的引用计数器为0，说明对象已经死亡 缺点 额外的空间来存储计数器 + 繁琐的更新操作 无法处理循环引用的场景，造成内存泄露">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-20.png">
<meta property="article:published_time" content="2018-12-26T00:59:28.000Z">
<meta property="article:modified_time" content="2023-04-03T10:04:59.586Z">
<meta property="article:author" content="zhongmingmao">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-20.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JVM基础 -- 垃圾回收基础",
  "url": "https://blog.zhongmingmao.top/2018/12/26/jvm-basic-gc/",
  "image": "https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-20.png",
  "datePublished": "2018-12-26T00:59:28.000Z",
  "dateModified": "2023-04-03T10:04:59.586Z",
  "author": [
    {
      "@type": "Person",
      "name": "zhongmingmao",
      "url": "https://blog.zhongmingmao.top"
    }
  ]
}</script><link rel="shortcut icon" href="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/z.png"><link rel="canonical" href="https://blog.zhongmingmao.top/2018/12/26/jvm-basic-gc/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":32,"languages":{"author":"Author: zhongmingmao","link":"Link: ","source":"Source: ByteCoding","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM基础 -- 垃圾回收基础',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ByteCoding" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/url(https:/cdn.pixabay.com/photo/2021/07/20/03/39/fisherman-6479663_1280.jpg));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/z.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">640</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">83</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-20.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ByteCoding</span></a><a class="nav-page-title" href="/"><span class="site-name">JVM基础 -- 垃圾回收基础</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">JVM基础 -- 垃圾回收基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2018-12-26T00:59:28.000Z" title="Created 2018-12-26 08:59:28">2018-12-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/jvm/">JVM</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/jvm/baisc/">Baisc</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">2.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>8mins</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:512,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2023-04-03 18:04:59&quot;}" hidden></div><h2 id="判定对象存亡"><a href="#判定对象存亡" class="headerlink" title="判定对象存亡"></a>判定对象存亡</h2><p>垃圾回收标记的是<strong>非垃圾</strong></p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><ol>
<li>为每个对象添加一个<strong>引用计数器</strong>，用来统计<strong>指向该对象的引用个数</strong><ul>
<li>如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器+1</li>
<li>如果指向某一对象的引用，被赋值为其他值，那么该对象的引用计数器-1</li>
</ul>
</li>
<li>一旦某个对象的引用计数器为<strong>0</strong>，说明对象已经<strong>死亡</strong></li>
<li>缺点<ul>
<li>额外的空间来存储计数器 + 繁琐的更新操作</li>
<li>无法处理<strong>循环引用</strong>的场景，造成<strong>内存泄露</strong></li>
</ul>
</li>
</ol>
<span id="more"></span>

<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><ol>
<li>将一系列<strong>GC Roots</strong>作为<strong>初识存活对象合集</strong><ul>
<li>标记：从该集合出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中</li>
<li>最终未被探索到的对象便是死亡，可以被回收</li>
</ul>
</li>
<li>GC Roots：<strong>堆外指向堆内的引用</strong>，一般包括<ul>
<li>Java方法栈帧中的局部变量</li>
<li>已加载类的静态变量</li>
<li>已启动且未停止的Java线程</li>
<li>JNI MethodHandles</li>
</ul>
</li>
</ol>
<h2 id="STW-安全点"><a href="#STW-安全点" class="headerlink" title="STW + 安全点"></a>STW + 安全点</h2><ol>
<li>JVM中的<strong>STW</strong>是通过<strong>安全点机制</strong>来实现的</li>
<li>当JVM收到<strong>STW请求</strong>时，会等待<strong>所有的线程都到达安全点</strong>，才允许请求STW的线程进行<strong>独占地工作</strong></li>
<li>安全点的初衷并不是让其他线程停下，而是找到一个<strong>稳定的执行状态</strong><ul>
<li>在这个执行状态下，JVM的<strong>堆栈不会发生变化</strong></li>
<li>垃圾回收器能够<strong>安全地执行可达性分析</strong></li>
</ul>
</li>
<li>JNI：<ul>
<li>Java程序通过JNI执行本地代码时，如果本地代码不<strong>访问Java对象</strong>、<strong>调用Java方法</strong>或者<strong>返回至Java方法</strong></li>
<li>那么JVM的堆栈是不会发生改变的，这段本地代码可以作为一个<strong>安全点</strong></li>
<li>主要不离开这个安全点，JVM便能够在垃圾回收的<strong>同时</strong>，继续运行这段本地代码</li>
<li>JVM仅需要在上述3个操作对应的<strong>JNI API入口处</strong>进行<strong>安全点检测</strong><ul>
<li>测试是否有其他线程请求停留在安全点，就可以在必要的时候挂起当前线程</li>
</ul>
</li>
</ul>
</li>
<li>Java线程状态<ul>
<li>运行状态<ul>
<li>解释执行字节码</li>
<li>执行即时编译生成的机器码</li>
<li>JVM需要<strong>在可预见的时间内进入安全点</strong>，否则<strong>垃圾回收线程可能长期处于等待所有线程进入安全点的状态</strong>，反而提高了垃圾回收的暂停时间</li>
</ul>
</li>
<li>线程阻塞<ul>
<li>阻塞的线程处于<strong>JVM线程调度器的掌控之下</strong>，属于<strong>安全点</strong></li>
</ul>
</li>
</ul>
</li>
<li>解析执行<ul>
<li><strong>字节码与字节码之间皆可作为安全点</strong></li>
<li>当有<strong>安全点请求</strong>时，<strong>执行一条字节码便进行一次安全点检测</strong></li>
</ul>
</li>
<li>执行即时编译生成的机器码<ul>
<li>代码直接运行在底层硬件上，<strong>不受JVM掌控</strong></li>
<li>在即时编译时，需要<strong>插入安全点检测</strong>，<strong>避免机器码长时间没有安全点检测的情况</strong></li>
<li>为什么不在<strong>每一条机器码</strong>或者<strong>每一个机器码基本块</strong>处插入安全点检测<ul>
<li>性能开销：安全点检测本身也有一定的<strong>开销</strong></li>
<li>内存开销：即时编译器生成的机器码打乱了原本栈帧上的对象分布状况，为了方便垃圾回收器能够枚举GC Roots，需要不少的<strong>额外空间</strong>来存储额外信息</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="垃圾回收的方式"><a href="#垃圾回收的方式" class="headerlink" title="垃圾回收的方式"></a>垃圾回收的方式</h2><h3 id="清除（Sweep）"><a href="#清除（Sweep）" class="headerlink" title="清除（Sweep）"></a>清除（Sweep）</h3><ol>
<li>把死亡对象所占据的内存标记为空闲内存，并记录在一个<strong>空闲列表</strong>中</li>
<li>当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象</li>
<li>缺点<ul>
<li><strong>内存碎片：JVM堆中的对象必须是连续分布的</strong></li>
<li><strong>分配效率低下：逐个访问列表中的项，来查找能够放入新建对象的空闲内存</strong></li>
</ul>
</li>
</ol>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://jvm-1253868755.cos.ap-guangzhou.myqcloud.com/basic/jvm-basic-gc-sweep.png" width=600/>


<h3 id="压缩（Compact）"><a href="#压缩（Compact）" class="headerlink" title="压缩（Compact）"></a>压缩（Compact）</h3><ol>
<li>把<strong>存活对象</strong>聚集到内存区域的<strong>起始位置</strong>，从而留下一段<strong>连续的内存空间</strong></li>
<li>能<strong>解决内存碎片</strong>的问题，代价为<strong>压缩算法的性能开销</strong></li>
</ol>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://jvm-1253868755.cos.ap-guangzhou.myqcloud.com/basic/jvm-basic-gc-compact.png" width=600/>

<h3 id="复制（Copy）"><a href="#复制（Copy）" class="headerlink" title="复制（Copy）"></a>复制（Copy）</h3><ol>
<li>把内存区域划分为<strong>两等分</strong>，分别用from和to指针来维护，<strong>from指针</strong>指向的内存区域用来<strong>分配内存</strong></li>
<li>当发生垃圾回收时，便<strong>把存活的对象复制到to指针指向的内存区域</strong>，并且<strong>交换from指针和to指针的内容</strong></li>
<li>同样能<strong>解决内存碎片</strong>的问题，代价为<strong>堆空间的使用效率极其低下</strong></li>
<li>压缩也需要复制数据<ul>
<li>压缩：需要<strong>复杂的算法</strong>保证引用能够正确更新</li>
<li>复制：可以在<strong>复制完成后统一更新</strong>引用</li>
</ul>
</li>
</ol>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://jvm-1253868755.cos.ap-guangzhou.myqcloud.com/basic/jvm-basic-gc-copy.png" width=600/>

<h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><ol>
<li>分代回收的背景：大部分Java对象只存活一小段时间，而存活下来的小部分Java对象会存活很长时间</li>
<li>将堆空间划分为新生代和老年代，新生代用于存储新建对象，如果对象存活时间足够长，则会被移动到老年代</li>
<li>对应新生代，Java对象只存活很短时间，因此可以<strong>频繁</strong>地采用<strong>耗时较短</strong>的垃圾回收算法</li>
<li>对于老年代，由于在一般情况下大部分垃圾已经在新生代被回收，而在老年代的对象很大概率会继续存活，如果触发老年代回收，说明<ul>
<li>新生代并没有回收大部分本该回收的垃圾</li>
<li>堆空间已经耗尽</li>
</ul>
</li>
<li>对于老年代回收，JVM将做一次<strong>全堆扫描</strong>，<strong>耗时可能将不计成本</strong></li>
</ol>
<h2 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h2><h3 id="堆划分"><a href="#堆划分" class="headerlink" title="堆划分"></a>堆划分</h3><ol>
<li>新生代将分为Eden区和两个大小相同的Survivor区</li>
<li>默认情况下，JVM采取<strong>动态分配</strong>的策略（**-XX:+UsePSAdaptiveSurvivorSizePolicy**）<ul>
<li>依据<strong>生成对象的速率</strong>，以及<strong>Survivor区的使用情况</strong>动态调整Eden区和Survivor区的比例</li>
<li>也可以通过**-XX:SurvivorRatio&#x3D;8**来固定这个比例</li>
<li>其中一个Survivor区会<strong>一直为空</strong>，比例越低堆空间浪费越严重</li>
</ul>
</li>
<li>调用<strong>new</strong>指令时，会在<strong>Eden</strong>区划出一块作为存储对象的内存<ul>
<li>由于<strong>堆空间</strong>是<strong>内存共享</strong>的，因此需要<strong>同步</strong></li>
<li>JVM采用的技术为<strong>TLAB</strong>（Thread Local Allocation Buffer），-XX:+UseTLAB，<strong>默认开启</strong></li>
</ul>
</li>
</ol>
<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://jvm-1253868755.cos.ap-guangzhou.myqcloud.com/basic/jvm-basic-gc-heap.png" width=600/>

<h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><ol>
<li>每个<strong>线程</strong>可以向JVM申请一段<strong>连续的内存</strong>，作为<strong>线程私有的TLAB</strong><ul>
<li>这个操作需要<strong>加锁</strong>，线程需要维护两个指针，一个指向<strong>TLAB中空余内存的起始位置</strong>，一个指向<strong>TLAB的末尾</strong></li>
</ul>
</li>
<li>new指令，直接通过<strong>指针加法</strong>来实现，即把指向空余内存位置的指针加上所请求的字节数<ul>
<li>如果加法后空余内存指针的值仍然小于等于指向末尾的指针，代表分配成功</li>
<li>否则TLAB已经没有足够的空间来满足本次新建操作，这个时候需要当前线程<strong>重新申请新的TLAB</strong></li>
</ul>
</li>
</ol>
<h3 id="Minor-GC-1"><a href="#Minor-GC-1" class="headerlink" title="Minor GC"></a>Minor GC</h3><ol>
<li>当<strong>Eden区的空间被耗尽</strong>，JVM会触发一个<strong>Minor GC</strong>，来<strong>回收新生代的垃圾</strong></li>
<li>当发生Minor GC时，<strong>Eden区和from指向的Survivor区中的存活对象会被复制到to指向的Survivor区</strong>，然后交换from和to指针</li>
<li>JVM会记录Survivor区中的对象一共被来回复制了几次<ul>
<li>当一个对象被复制的次数为-XX:+MaxTenuringThreshold&#x3D;15时，那么该对象将被晋升到老年代</li>
<li>15的原因是<strong>对象年龄</strong>（在对象头中）使用<strong>4bit</strong>记录</li>
</ul>
</li>
<li>如果Survivor区已经被占用-XX:TargetSurvivorRatio&#x3D;50%的时候，那么<strong>较高复制次数的对象</strong>也会被晋升到老年代</li>
<li>发生Minor GC时，采用<strong>标记-复制</strong>算法<ul>
<li>理想情况下，Eden区中的对象都<strong>基本死亡</strong>了，那么需要<strong>复制的数据是非常少</strong>的，效果将很好</li>
</ul>
</li>
<li>Minor GC<strong>无需对整个堆进行回收</strong><ul>
<li><strong>老年代的对象可能引用新生代的对象</strong></li>
<li>在之前，在标记存活对象的时候，需要扫描整个老年代中的对象</li>
<li><strong>如果老年代的对象拥有对新生代对象的引用，那么这个引用也会被作为GC Roots</strong></li>
<li>借助<strong>卡表</strong>，<strong>无需全堆扫描</strong></li>
</ul>
</li>
</ol>
<h3 id="卡表（HotSpot）"><a href="#卡表（HotSpot）" class="headerlink" title="卡表（HotSpot）"></a>卡表（HotSpot）</h3><ol>
<li>将<strong>整个堆</strong>划分为大小为<strong>512Bytes</strong>的卡，并且维护一个卡表，用来存储<strong>每张卡的标识位</strong><ul>
<li>标识位：<strong>对应的卡是否可能存在有指向新生代对象的引用</strong></li>
<li>如果<strong>可能存在</strong>，即认为这张卡是<strong>脏</strong>的</li>
</ul>
</li>
<li>在进行<strong>Minor GC</strong>的时候，便可以<strong>不用扫描整个老年代</strong>，而是<strong>在卡表中寻找脏卡</strong>，并将<strong>脏卡中的对象加入到Minor GC的GC Roots</strong>里<ul>
<li><strong>当完成所有脏卡的扫描后，JVM会将所有的脏卡的标识位清零</strong></li>
</ul>
</li>
<li>Minor GC伴随着<strong>存活对象的复制</strong>，而在复制的同时<strong>需要更新指向被复制对象的引用</strong><ul>
<li>在更新引用的同时，又可以<strong>设置引用所在卡的标识位</strong></li>
<li>在这个时候，可以<strong>确保脏卡中必定包含指向新生代对象的引用</strong></li>
</ul>
</li>
<li><strong>在（下一次）Minor GC之前，并不能确保脏卡中包含指向新生代对象的引用</strong><ul>
<li>如果想要保证每个可能有指向新生代对象引用的卡都被标记为脏卡，JVM需要<strong>截获每个引用类型实例变量的写操作</strong>，并作出对应的写标识位操作</li>
<li>在解释执行器中比较容易实现，在即时编译器生成的字节码中，需要插入额外的逻辑，即<strong>写屏障</strong></li>
<li>写屏障需要<strong>尽可能保持简洁</strong>，因为不能在每条引用型实例变量的写指令后注入大量的指令<ul>
<li><strong>写屏障并不会判断更新后的引用是否真的指向新生代中的对象，而是一律当成可能指向新生代对象的引用</strong></li>
<li>原则：<strong>宁杀错，勿放过</strong></li>
<li>伪代码：<code>CARD_TABLE [this address &gt;&gt; 9] = DIRTY;</code></li>
</ul>
</li>
<li>虽然写屏障存在一定开销，但能够<strong>加大Minor GC的吞吐量</strong> – AppTime&#x2F;(AppTime+GcTime)</li>
<li>在<strong>高并发</strong>环境下，写屏障会出现<strong>伪共享</strong>的问题<ul>
<li><strong>卡表中不同卡的标识位之间的伪共享</strong></li>
<li>在HotSpot中，使用-XX:+UseCondCardMark来尽量减少写卡表的操作</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100010301">深入拆解Java虚拟机</a></p>
<!-- indicate-the-source -->
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://blog.zhongmingmao.top">zhongmingmao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://blog.zhongmingmao.top/2018/12/26/jvm-basic-gc/">https://blog.zhongmingmao.top/2018/12/26/jvm-basic-gc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">Java</a><a class="post-meta__tags" href="/tags/jvm/">JVM</a></div><div class="post-share"><div class="social-share" data-image="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-20.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2018/12/30/jvm-basic-jmm/" title="JVM基础 -- Java内存模型"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-8.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">JVM基础 -- Java内存模型</div></div><div class="info-2"><div class="info-item-1">JIT的重排序Java代码1234567891011121314public class JMM &#123;    private int a = 0;    private int b = 0;    public void method1() &#123;        int r2 = a; // A1        b = 1; // A2    &#125;    public void method2() &#123;        int r1 = b; // B1        a = 2; // B2    &#125;&#125;   单线程，method1-&gt;method2，**(r1,r2)&#x3D;(1,0)** 单线程，method2-&gt;method1，**(r1,r2)&#x3D;(0,2)** 多线程，没有重排序，A1-&gt;B1-&gt;A2-&gt;B2，**(r1,r2)&#x3D;(0,0)** 多线程，重排序，A2-&gt;B1-&gt;B2-&gt;A1，**(r1,r2)&#x3D;(1,2)**    As-If-Serial 在单线程情...</div></div></div></a><a class="pagination-related" href="/2018/12/22/jvm-basic-jol/" title="JVM基础 -- Java对象的内存布局"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-14.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">JVM基础 -- Java对象的内存布局</div></div><div class="info-2"><div class="info-item-1">创建对象 new + 反射 通过调用构造器来初始化实例字段   Object.clone + 反序列化 通过直接复制已有的数据，来初始化新建对象的实例字段   Unsafe.allocateInstance 不会初始化实例字段    123456// Foo foo = new Foo();对应的字节码// new指令：请求内存0: new              // class me/zhongmingmao/basic/jol/Foo3: dup// invokespecial指令：调用构造器4: invokespecial    // Method &quot;&lt;init&gt;&quot;:()V    Java构造器默认构造器如果一个类没有定义任何构造器，那么Java编译器会自动添加一个无参数的构造器 Java代码123456// 未定义任何构造器public class Foo &#123;    public static void main(String[] args) &#123;        Foo foo = new Foo();    &#125;&#125;  字节...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/02/22/jvm-bytecode-manipulation-asm-introduction/" title="ASM - Introduction"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-17.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-22</div><div class="info-item-2">ASM - Introduction</div></div><div class="info-2"><div class="info-item-1">Glance ASM is an all purpose Java bytecode manipulation and analysis framework. It can be used to modify existing classes or to dynamically generate classes, directly in binary form.   ASM provides some common bytecode transformations and analysis algorithms from which custom complex transformations and code analysis tools can be built. ASM offers similar functionality as other Java bytecode frameworks, but is focused on performance. Because it was designed and implemented to be as small and as fast as p...</div></div></div></a><a class="pagination-related" href="/2022/02/11/jvm-bytecode-manipulation-javassist/" title="Bytecode Manipulation - Javassist"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-4.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-11</div><div class="info-item-2">Bytecode Manipulation - Javassist</div></div><div class="info-2"><div class="info-item-1">概要 Unlike other similar bytecode editors, Javassist provides two levels of API: source level and bytecode level.  生成字节码1234567891011121314151617package me.zhongmingmao.javassist;public class Point &#123;  private int x;  private int y;  public Point(int x, int y) &#123;    this.x = x;    this.y = y;  &#125;  public void move(int x, int y) &#123;    this.x = x;    this.y = y;  &#125;&#125;  12$ javac me/zhongmingmao/javassist/Point.java$ javap -v me.zhongmingmao.javassist.Point    123456789101112131415161...</div></div></div></a><a class="pagination-related" href="/2022/02/10/jvm-bytecode-manipulation-java-agent-practice/" title="Bytecode Manipulation - Java Agent Practice"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-23.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-10</div><div class="info-item-2">Bytecode Manipulation - Java Agent Practice</div></div><div class="info-2"><div class="info-item-1">概念Instrument Instrument 是 JVM 提供的一个可以修改已加载类的类库，依赖于 JVMTI 的 Attach API 机制 要使用 Instrument 的类修改功能，需要实现 java.lang.instrument.ClassFileTransformer 接口 可以在 ClassFileTransformer#transform 中利用 ASM 或者 Byte Buddy 等工具对字节码进行操作   Instrument 通过与 Java Agent 结合来注入到 JVM 中  JVMTI &amp; Agent JPDA（Java Platform Debugger Architecture）是 JDK 标准，必须实现 如果 JVM 启动时开启了 JPDA，那么类是允许被重新加载的 已加载的旧版类信息被卸载，然后重新加载新版本的类   JVMTI 是 JVM 提供的一套对 JVM 进行操作的工具接口，Agent 是 JVMTI 的一种实现 Attach API 的作用：提供 JVM 进程间通信的能力 Attach 后，目标 JVM 在运行时走到 Agent 中定义的 age...</div></div></div></a><a class="pagination-related" href="/2019/09/13/java-performance-jvm-heap-allocation/" title="Java性能 -- JVM堆内存分配"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-2.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-13</div><div class="info-item-2">Java性能 -- JVM堆内存分配</div></div><div class="info-2"><div class="info-item-1">JVM内存分配性能问题 JVM内存分配不合理最直接的表现就是频繁的GC，这会导致上下文切换，从而降低系统的吞吐量，增加系统的响应时间  对象在堆中的生命周期 在JVM内存模型的堆中，堆被划分为新生代和老年代 新生代又被进一步划分为Eden区和Survivor区，Survivor区由From Survivor和To Survivor组成   当创建一个对象时，对象会被优先分配到新生代的Eden区 此时JVM会给对象定义一个对象年轻计数器（-XX:MaxTenuringThreshold）   当Eden空间不足时，JVM将执行新生代的垃圾回收（Minor GC） JVM会把存活的对象转移到Survivor中，并且对象年龄+1 对象在Survivor中同样也会经历Minor GC，每经历一次Minor GC，对象年龄都会+1   如果分配的对象超过了-XX:PetenureSizeThreshold，对象会直接被分配到老年代    查看JVM堆内存分配 在默认不配置JVM堆内存大小的情况下，JVM根据默认值来配置当前内存大小 在JDK 1.7中，默认情况下新生代和老年代的比例是1:2，可以通过–XX:New...</div></div></div></a><a class="pagination-related" href="/2019/09/11/java-performance-gc/" title="Java性能 -- GC"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-6.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-11</div><div class="info-item-2">Java性能 -- GC</div></div><div class="info-2"><div class="info-item-1">GC机制回收区域 JVM的内存区域中，程序计数器、虚拟机栈、本地方法栈是线程私有，随线程的创建而创建，销毁而销毁 栈中的栈帧随着方法的进入和退出进行入栈和出栈操作，每个栈帧分配多少内存基本是在类结构确定下来时就已知 因此，这三个区域的内存分配和回收都是具有确定性的   堆中的回收主要是对象回收，方法区的回收主要是废弃常量和无用类的回收    回收时机 当一个对象不再被引用，就代表该对象可以被回收 引用计数法：实现简单，判断效率高，但存在循环引用的问题 可达性分析算法：HotSpot VM     引用类型 功能特点    强引用（Strong Reference） 被强引用关联的对象，永远不会被垃圾回收器回收   软引用（Soft Reference） 被软引用关联的对象，只有当系统将要发生内存溢出时，才会去回收软引用关联的对象   弱引用（Weak Reference） 只被弱引用关联的对象，只要发生GC事件，就会被回收   虚引用（Phantom Reference） 被虚引用关联的对象，唯一作用是在这个对象被回收时收到一个系统通知   回收特性 自动性 Java提供了一个系统级的线程来跟踪每一块分...</div></div></div></a><a class="pagination-related" href="/2019/09/09/java-performance-jit/" title="Java性能 -- JIT"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-3.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-09</div><div class="info-item-2">Java性能 -- JIT</div></div><div class="info-2"><div class="info-item-1">编译 前端编译：即常见的**.java文件被编译成.class文件**的过程 运行时编译：机器无法直接运行Java生成的字节码，在运行时，JIT或者解释器会将字节码转换为机器码 类文件在运行时被进一步编译，可以变成高度优化的机器代码   C&#x2F;C++编译器的所有优化都是在编译期完成的，运行期的性能监控仅作为基础的优化措施是无法进行的 JIT编译器是JVM中运行时编译最重要的部分之一    编译 &#x2F; 加载 &#x2F; 执行  类编译 javac：将.java文件编译成.class文件 javap：反编译.class文件，重点关注常量池和方法表集合 常量池主要记录的是类文件中出现的字面量和符号引用 字面量：字符串常量、基本类型的常量 符号引用：类和接口的全限定名、类引用、方法引用、成员变量引用   方法表集合 方法的字节码、方法访问权限、方法名索引、描述符索引、JVM执行指令、属性集合等        类加载 当一个类被创建实例或者被其他对象引用时，JVM如果没有加载过该类，会通过类加载器将**.class文件加载到内存**中 不同的实现类由不同的类加载器加载 JDK中的本地方法类一般由...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/z.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">zhongmingmao</div><div class="author-info-description">Focus on Infrastructure.</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">640</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">83</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="mailto:zhongmingmao0625@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Things are always unexpected!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E5%AD%98%E4%BA%A1"><span class="toc-number">1.</span> <span class="toc-text">判定对象存亡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">可达性分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STW-%E5%AE%89%E5%85%A8%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">STW + 安全点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">垃圾回收的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%EF%BC%88Sweep%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">清除（Sweep）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%EF%BC%88Compact%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">压缩（Compact）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%EF%BC%88Copy%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">复制（Copy）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">4.</span> <span class="toc-text">分代回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Minor-GC"><span class="toc-number">5.</span> <span class="toc-text">Minor GC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%88%92%E5%88%86"><span class="toc-number">5.1.</span> <span class="toc-text">堆划分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TLAB"><span class="toc-number">5.1.1.</span> <span class="toc-text">TLAB</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minor-GC-1"><span class="toc-number">5.2.</span> <span class="toc-text">Minor GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A1%E8%A1%A8%EF%BC%88HotSpot%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">卡表（HotSpot）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">6.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/22/cloud-native-observability-prometheus-introduction/" title="Observability - Prometheus Introduction"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://observability-1253868755.cos.ap-guangzhou.myqcloud.com/prometheus.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Observability - Prometheus Introduction"/></a><div class="content"><a class="title" href="/2025/01/22/cloud-native-observability-prometheus-introduction/" title="Observability - Prometheus Introduction">Observability - Prometheus Introduction</a><time datetime="2025-01-21T16:06:25.000Z" title="Created 2025-01-22 00:06:25">2025-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/21/cloud-native-observability-opentelemetry-java-zero-code/" title="Observability - OpenTelemetry Java Zero Code"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://observability-1253868755.cos.ap-guangzhou.myqcloud.com/otel-java-agent.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Observability - OpenTelemetry Java Zero Code"/></a><div class="content"><a class="title" href="/2025/01/21/cloud-native-observability-opentelemetry-java-zero-code/" title="Observability - OpenTelemetry Java Zero Code">Observability - OpenTelemetry Java Zero Code</a><time datetime="2025-01-20T16:06:25.000Z" title="Created 2025-01-21 00:06:25">2025-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/20/cloud-native-observability-opentelemetry-java/" title="Observability - OpenTelemetry Java"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://observability-1253868755.cos.ap-guangzhou.myqcloud.com/otel-java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Observability - OpenTelemetry Java"/></a><div class="content"><a class="title" href="/2025/01/20/cloud-native-observability-opentelemetry-java/" title="Observability - OpenTelemetry Java">Observability - OpenTelemetry Java</a><time datetime="2025-01-19T16:06:25.000Z" title="Created 2025-01-20 00:06:25">2025-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/19/ai-agent-overview-mcp/" title="AI Agent - MCP Overview"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ai-agent-1253868755.cos.ap-guangzhou.myqcloud.com/mcp.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI Agent - MCP Overview"/></a><div class="content"><a class="title" href="/2025/01/19/ai-agent-overview-mcp/" title="AI Agent - MCP Overview">AI Agent - MCP Overview</a><time datetime="2025-01-18T16:06:25.000Z" title="Created 2025-01-19 00:06:25">2025-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/18/ai-agent-overview/" title="AI Agent - Overview"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ai-agent-1253868755.cos.ap-guangzhou.myqcloud.com/ai-agent.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI Agent - Overview"/></a><div class="content"><a class="title" href="/2025/01/18/ai-agent-overview/" title="AI Agent - Overview">AI Agent - Overview</a><time datetime="2025-01-17T16:06:25.000Z" title="Created 2025-01-18 00:06:25">2025-01-18</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2015 - 2025 By zhongmingmao</span></div><div class="footer_custom_text">Life is like a box of chocolates. You can't know what you'll eat until you open it.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div></body></html>