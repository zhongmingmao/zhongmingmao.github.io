<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM基础 -- 方法调用 | ByteCoding</title><meta name="author" content="zhongmingmao"><meta name="copyright" content="zhongmingmao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="重载+重写 重载：方法名相同，但方法描述符不相同的方法之间的关系 重写：方法名相同，并且方法描述符也相同的方法之间的关系 方法描述符 Java：参数类型 JVM：参数类型+返回类型    重载 重载的方法在编译过程即可完成识别 具体到在每个方法调用时，Java编译器会根据传入参数的声明类型（不是实际类型）来选取重载方法   三阶段 在不允许自动装拆箱和可变长参数的情况下，选取重载方法 允许自动装拆">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM基础 -- 方法调用">
<meta property="og:url" content="https://blog.zhongmingmao.top/2018/12/17/jvm-basic-invoke/index.html">
<meta property="og:site_name" content="ByteCoding">
<meta property="og:description" content="重载+重写 重载：方法名相同，但方法描述符不相同的方法之间的关系 重写：方法名相同，并且方法描述符也相同的方法之间的关系 方法描述符 Java：参数类型 JVM：参数类型+返回类型    重载 重载的方法在编译过程即可完成识别 具体到在每个方法调用时，Java编译器会根据传入参数的声明类型（不是实际类型）来选取重载方法   三阶段 在不允许自动装拆箱和可变长参数的情况下，选取重载方法 允许自动装拆">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-18.png">
<meta property="article:published_time" content="2018-12-17T13:06:47.000Z">
<meta property="article:modified_time" content="2023-04-03T10:04:59.586Z">
<meta property="article:author" content="zhongmingmao">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-18.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JVM基础 -- 方法调用",
  "url": "https://blog.zhongmingmao.top/2018/12/17/jvm-basic-invoke/",
  "image": "https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-18.png",
  "datePublished": "2018-12-17T13:06:47.000Z",
  "dateModified": "2023-04-03T10:04:59.586Z",
  "author": [
    {
      "@type": "Person",
      "name": "zhongmingmao",
      "url": "https://blog.zhongmingmao.top"
    }
  ]
}</script><link rel="shortcut icon" href="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/z.png"><link rel="canonical" href="https://blog.zhongmingmao.top/2018/12/17/jvm-basic-invoke/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":32,"languages":{"author":"Author: zhongmingmao","link":"Link: ","source":"Source: ByteCoding","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM基础 -- 方法调用',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ByteCoding" type="application/atom+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(/url(https:/cdn.pixabay.com/photo/2021/07/20/03/39/fisherman-6479663_1280.jpg));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/z.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">641</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">83</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-18.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ByteCoding</span></a><a class="nav-page-title" href="/"><span class="site-name">JVM基础 -- 方法调用</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">JVM基础 -- 方法调用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2018-12-17T13:06:47.000Z" title="Created 2018-12-17 21:06:47">2018-12-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/jvm/">JVM</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/jvm/baisc/">Baisc</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>13mins</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:512,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2023-04-03 18:04:59&quot;}" hidden></div><h2 id="重载-重写"><a href="#重载-重写" class="headerlink" title="重载+重写"></a>重载+重写</h2><ol>
<li>重载：方法名相同，但方法描述符不相同的方法之间的关系</li>
<li>重写：方法名相同，并且方法描述符也相同的方法之间的关系</li>
<li>方法描述符<ol>
<li><strong>Java：参数类型</strong></li>
<li><strong>JVM：参数类型+返回类型</strong></li>
</ol>
</li>
</ol>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ol>
<li>重载的方法在<strong>编译过程</strong>即可完成识别<ul>
<li>具体到在每个方法调用时，Java编译器会根据<strong>传入参数的声明类型</strong>（不是实际类型）来选取重载方法</li>
</ul>
</li>
<li>三阶段<ul>
<li>在不允许<strong>自动装拆箱</strong>和<strong>可变长参数</strong>的情况下，选取重载方法</li>
<li>允许<strong>自动装拆箱</strong>，但不允许<strong>可变长参数</strong>的情况下，选取重载方法</li>
<li>在允许<strong>自动装拆箱</strong>和<strong>可变长参数</strong>的情况下，选取重载方法</li>
</ul>
</li>
<li>Java编译器在<strong>同一阶段</strong>找到多个适配的方法，依据<strong>形式参数的继承关系</strong>，选择最贴切的方法，原则：<strong>子类优先</strong></li>
<li>重载来源<ul>
<li><strong>同一个类中定义</strong></li>
<li><strong>继承父类非私有同名方法</strong></li>
</ul>
</li>
</ol>
<span id="more"></span>

<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><ol>
<li>子类中定义了与父类中<strong>非私有的同名实例方法</strong>，且<strong>参数类型相同</strong><ul>
<li>如果是<strong>静态方法</strong>，那么子类中的方法会<strong>隐藏</strong>父类中方法</li>
</ul>
</li>
<li>方法<strong>重写</strong>是Java<strong>多态</strong>最重要的一种体现形式</li>
</ol>
<h2 id="静态绑定与-动态绑定"><a href="#静态绑定与-动态绑定" class="headerlink" title="静态绑定与+动态绑定"></a>静态绑定与+动态绑定</h2><ol>
<li>JVM识别<strong>重载方法</strong>的关键在于<strong>类名</strong>，<strong>方法名</strong>和<strong>方法描述符</strong><ul>
<li>方法描述符：<strong>参数类型 + 返回类型</strong></li>
<li>如果在同一个类中出现多个<strong>方法名</strong>和<strong>方法描述符</strong>也相同的方法，那么JVM会在类的<strong>验证阶段报错</strong></li>
<li>JVM的限制比Java语言的<strong>限制更少</strong>，Java语言：<strong>方法描述符 &#x3D; 方法的参数类型</strong></li>
</ul>
</li>
<li>JVM中关于<strong>重写方法</strong>的判定同样基于<strong>方法描述符</strong><ul>
<li>如果子类定义了与父类中<strong>非私有实例方法同名的方法</strong>，那么只有当这两个方法的<strong>参数类型</strong>以及<strong>返回类型</strong>一致，JVM才会判定为重写</li>
</ul>
</li>
<li><strong>Java语言中的重写</strong>而<strong>JVM中的非重写</strong>，编译器会通过生成<strong>桥接方法</strong>来实现Java中的重写语义，保证Java语言和JVM表现出来的重写语义一致</li>
<li>对重载方法的区分在<strong>编译阶段</strong>已经完成，可以认为<strong>JVM不存在重载这一概念</strong></li>
<li><strong>静态绑定</strong>：在<strong>解析阶段</strong>时能够<strong>直接识别</strong>目标方法</li>
<li><strong>动态绑定</strong>：在<strong>运行过程</strong>中<strong>根据调用者的动态类型</strong>来识别目标方法</li>
<li>重载 &#x3D;&#x3D; 静态绑定，重写 &#x3D;&#x3D; 动态绑定？<ul>
<li>反例：<strong>重载不一定是静态绑定</strong>（某个类的重载方法可能被它的子类所重写）</li>
<li>反例：<strong>重写不一定是动态绑定</strong>（final修饰目标方法）</li>
<li>Java编译器会将<strong>对非私有实例方法的调用</strong>都编译为需要<strong>动态绑定</strong>的类型（可能进一步优化）</li>
<li><strong>重载&#x2F;重写</strong> 和 <strong>静态绑定&#x2F;动态绑定</strong> 是<strong>两个不同纬度的描述</strong></li>
</ul>
</li>
</ol>
<h3 id="重载不一定是静态绑定"><a href="#重载不一定是静态绑定" class="headerlink" title="重载不一定是静态绑定"></a>重载不一定是静态绑定</h3><h4 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Overload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">// invokevirtual指令：A.func(int)和A.func(long)形成重载，但需要动态绑定</span></span><br><span class="line">        a.func(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">long</span> i)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=1</span><br><span class="line">         0: new           #2                  // class me/zhongmingmao/basic/invoke/bind/B</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #3                  // Method me/zhongmingmao/basic/invoke/bind/B.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: aload_1</span><br><span class="line">         9: iconst_1</span><br><span class="line">         // 虚方法调用</span><br><span class="line">        10: invokevirtual #4                  // Method me/zhongmingmao/basic/invoke/bind/A.func:(I)V</span><br><span class="line">        13: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">        line 7: 8</span><br><span class="line">        line 8: 13</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      14     0  args   [Ljava/lang/String;</span><br><span class="line">            8       6     1     a   Lme/zhongmingmao/basic/invoke/bind/A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重写不一定是动态绑定"><a href="#重写不一定是动态绑定" class="headerlink" title="重写不一定是动态绑定"></a>重写不一定是动态绑定</h3><h4 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Override</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        <span class="comment">// C.func()的flags为：ACC_FINAL</span></span><br><span class="line">        <span class="comment">// JVM能确定目标方法只有一个，invokevirtual指令将采用静态绑定</span></span><br><span class="line">        c.func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字节码-1"><a href="#字节码-1" class="headerlink" title="字节码"></a>字节码</h4><p>C</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">final void func();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_FINAL</span><br><span class="line">    Code:</span><br><span class="line">      stack=0, locals=1, args_size=1</span><br><span class="line">         0: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       1     0  this   Lme/zhongmingmao/basic/invoke/bind/C;</span><br></pre></td></tr></table></figure>
<p>Override</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  descriptor: ([Ljava/lang/String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=2, args_size=1</span><br><span class="line">       0: new           #2                  // class me/zhongmingmao/basic/invoke/bind/C</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #3                  // Method me/zhongmingmao/basic/invoke/bind/C.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: invokevirtual #4                  // Method me/zhongmingmao/basic/invoke/bind/C.func:()V</span><br><span class="line">      12: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 6: 0</span><br><span class="line">      line 7: 8</span><br><span class="line">      line 8: 12</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0      13     0  args   [Ljava/lang/String;</span><br><span class="line">          8       5     1     d   Lme/zhongmingmao/basic/invoke/bind/C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用相关的指令"><a href="#调用相关的指令" class="headerlink" title="调用相关的指令"></a>调用相关的指令</h2><h3 id="具体指令"><a href="#具体指令" class="headerlink" title="具体指令"></a>具体指令</h3><ol>
<li>invokestatic：调用静态方法</li>
<li>invokespecial<ul>
<li>调用<strong>私有实例方法</strong>、构造器</li>
<li>使用<strong>super</strong>关键词调用父类的实例方法、构造器</li>
<li>调用所实现接口的<strong>default方法</strong></li>
</ul>
</li>
<li>invokevirtual：调用<strong>非私有实例方法</strong></li>
<li>invokeinterface：调用接口方法</li>
<li>invokedynamic：调用动态方法（比较复杂）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isVip</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Merchant</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">ORIGINAL_DISCOUNT</span> <span class="operator">=</span> <span class="number">0.8d</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">discount</span><span class="params">(<span class="type">double</span> originalPrice, Customer customer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> originalPrice * ORIGINAL_DISCOUNT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Profiteer</span> <span class="keyword">extends</span> <span class="title class_">Merchant</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">discount</span><span class="params">(<span class="type">double</span> originalPrice, Customer customer)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (customer.isVip()) &#123; <span class="comment">// invokeinterface</span></span><br><span class="line">            <span class="keyword">return</span> originalPrice * priceDiscrimination(); <span class="comment">// invokestatic</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.discount(originalPrice, customer); <span class="comment">// invokespecial</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">priceDiscrimination</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>() <span class="comment">// invokespecial</span></span><br><span class="line">                .nextDouble() <span class="comment">// invokevirtual</span></span><br><span class="line">                + ORIGINAL_DISCOUNT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定位目标方法"><a href="#定位目标方法" class="headerlink" title="定位目标方法"></a>定位目标方法</h3><ol>
<li>对于<strong>invokestatic</strong>和<strong>invokespecial</strong>，JVM在<strong>解析阶段</strong>能够<strong>直接识别</strong>具体的目标方法</li>
<li>对于<strong>invokevirtual</strong>和<strong>invokeinterface</strong>，在绝大部分情况下，JVM需要在<strong>执行过程</strong>中，根据<strong>调用者的动态类型</strong>，来确定具体的目标方法<ul>
<li>唯一例外：如果JVM能确定目标方法<strong>有且只有一个</strong>，例如目标方法被标记为final</li>
</ul>
</li>
</ol>
<h3 id="调用指令的符号引用"><a href="#调用指令的符号引用" class="headerlink" title="调用指令的符号引用"></a>调用指令的符号引用</h3><ol>
<li>在编译过程中，并不知道目标方法的具体内存地址，因此，Java编译器会暂时用<strong>符号引用</strong>来表示该目标方法<ul>
<li>符号引用包括：<strong>目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符</strong></li>
</ul>
</li>
<li><strong>符号引用</strong>存储在<strong>class文件的常量池之中</strong>，根据<strong>目标方法是否为接口方法</strong>，这些引用可分为<strong>接口符号引用</strong>和<strong>非接口符号引用</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ javap -v Profiteer</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #8.#30         // me/zhongmingmao/basic/Merchant.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = InterfaceMethodref #31.#32        // me/zhongmingmao/basic/Customer.isVip:()Z</span><br><span class="line">   #3 = Methodref          #11.#33        // me/zhongmingmao/basic/Profiteer.priceDiscrimination:()D</span><br><span class="line">   #4 = Methodref          #8.#34         // me/zhongmingmao/basic/Merchant.discount:(DLme/zhongmingmao/basic/Customer;)D</span><br><span class="line">...</span><br><span class="line">   #6 = Methodref          #5.#30         // java/util/Random.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #7 = Methodref          #5.#36         // java/util/Random.nextDouble:()D</span><br></pre></td></tr></table></figure>

<h4 id="目标方法的查找步骤"><a href="#目标方法的查找步骤" class="headerlink" title="目标方法的查找步骤"></a>目标方法的查找步骤</h4><ol>
<li>对于<strong>非接口符号引用</strong>，假设该符号引用所指向的类为C，查找步骤<ul>
<li>在C中查找符合名字和描述符的方法</li>
<li>如果没有找到，在C的<strong>父类</strong>中继续搜索，直至Object类</li>
<li>如果没有找到，在C所<strong>直接实现或间接实现的接口</strong>中搜索，这一步搜索得到的目标方法必须是<strong>非私有、非静态</strong>的<ul>
<li>如果目标方法在<strong>间接接口</strong>中，则需要满足<strong>C与该接口之间没有其他符合条件的目标方法</strong> – 越近，优先级越高</li>
<li>如果有<strong>多个符合条件的目标方法</strong>，则<strong>任意返回</strong>其中一个</li>
</ul>
</li>
<li><strong>静态方法</strong> 也可以通过<strong>子类</strong>来调用，子类的静态方法会<strong>隐藏</strong>父类中同名同描述符的静态方法</li>
</ul>
</li>
<li>对于<strong>接口符号引用</strong>，假设该符号引用所指向的接口为I，查找步骤<ul>
<li>在I中查找符合名字和描述符的方法</li>
<li>如果没有找到，在<strong>Object类中的公有实例方法</strong>中搜索</li>
<li>如果没有找到，则在I的<strong>超接口</strong>中搜索，这一步的搜索结果的要求<strong>与非接口符号引用的要求一致</strong></li>
</ul>
</li>
<li>经过上述的<strong>解析</strong>步骤之后，<strong>符号引用会被解析成实际引用</strong><ul>
<li>对于可以<strong>静态绑定</strong>的方法调用而言，实际引用的是<strong>一个指向方法的指针</strong></li>
<li>对于需要<strong>动态绑定</strong>的方法调用而言，实际引用则是<strong>一个虚方法表的索引</strong></li>
</ul>
</li>
</ol>
<h2 id="虚方法调用"><a href="#虚方法调用" class="headerlink" title="虚方法调用"></a>虚方法调用</h2><ol>
<li>JVM的虚方法调用指令<ul>
<li>Java里所有<strong>非私有实例方法的调用</strong>都会编译成<strong>invokevirtual</strong>指令（<strong>绝大数情况下动态绑定</strong>）</li>
<li>而<strong>接口方法调用</strong>都会被编译成<strong>invokeinterface</strong>指令</li>
</ul>
</li>
<li>在绝大数情况下，JVM需要根据<strong>调用者的动态类型</strong>，来<strong>确定虚方法调用的目标方法</strong>，这个过程称之为<strong>动态绑定</strong><ul>
<li>相对于静态绑定的非虚方法调用来说，<strong>虚方法调用更加耗时</strong></li>
</ul>
</li>
<li>静态绑定<ul>
<li>调用静态方法的<strong>invokestatic</strong>指令</li>
<li>调用构造器、私有实例方法和父类非私有实例方法（可继承）的<strong>invokespecial</strong>指令<ul>
<li>父类非私有实例方法：本意是要调用父类的特定方法，而非根据具体类型决定目标方法</li>
</ul>
</li>
<li>如果<strong>虚方法调用</strong>指向一个<strong>标记为final</strong>的方法，那么JVM也可以<strong>静态绑定</strong>该虚方法调用的目标方法</li>
</ul>
</li>
</ol>
<h2 id="虚方法表（链接-准备阶段）"><a href="#虚方法表（链接-准备阶段）" class="headerlink" title="虚方法表（链接-准备阶段）"></a>虚方法表（链接-准备阶段）</h2><ol>
<li>虚方法表：JVM采取了一种用<strong>空间换时间</strong>的策略来实现<strong>动态绑定</strong></li>
<li>invokevirtual的虚方法表与invokeinterface的虚方法表类似</li>
<li>虚方法表本质上是一个<strong>数组</strong>，每个数组元素指向<strong>当前类及其父类中非私有、非final的实例方法</strong></li>
<li>虚方法表的特性<ul>
<li><strong>子类虚方法表中包含父类虚方法表中的所有方法</strong></li>
<li>子类方法在虚方法表中的<strong>索引值</strong>，与它<strong>所重写的父类方法的索引值相同</strong></li>
</ul>
</li>
<li>方法调用指令中的<strong>符号引用</strong>会在<strong>执行之前</strong>解析成<strong>实际引用</strong><ul>
<li>对于<strong>静态绑定</strong>的方法调用而言，实际引用将指向<strong>具体的目标方法</strong></li>
<li>对于<strong>动态绑定</strong>的方法调用而言，实际引用则是<strong>虚方法表的索引</strong>（不仅仅是索引值）</li>
</ul>
</li>
<li>动态绑定：JVM将<strong>获取调用者的实际类型</strong>，并在<strong>实际类型的虚方法表</strong>中，根据<strong>索引值</strong>获得<strong>目标方法</strong></li>
<li>使用虚方法表的动态绑定与静态绑定相比，<strong>仅仅多出几个内存解引用操作</strong>（相对于创建和初始化栈帧来说，开销很小）<ul>
<li>访问<strong>栈</strong>上的调用者</li>
<li>读取调用者的<strong>动态类型</strong></li>
<li>读取该类型的<strong>虚方法表</strong></li>
<li>读取虚方法表某个<strong>索引值</strong>所对应的<strong>目标方法</strong></li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -XX:CompileCommand=dontinline,*.outBound</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokeVirtual</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Passenger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foreigner</span>();</span><br><span class="line">        <span class="type">Passenger</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">2_000_000_000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">half_count</span> <span class="operator">=</span> count / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">            <span class="type">Passenger</span> <span class="variable">c</span> <span class="operator">=</span> (i &lt; half_count) ? a : b;</span><br><span class="line">            c.outBound();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 超多态内存缓存（方法表）：6700ms</span></span><br><span class="line">        <span class="comment">// 单态内联缓存：2315ms</span></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;ms&quot;</span>, end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Passenger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">outBound</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foreigner</span> <span class="keyword">extends</span> <span class="title class_">Passenger</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outBound</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chinese</span> <span class="keyword">extends</span> <span class="title class_">Passenger</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outBound</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shopping</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Passenger的方法表</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Passenger.toString()</td>
<td>重写Object.toString()</td>
</tr>
<tr>
<td>1</td>
<td>Passenger.outBound()</td>
<td>抽象方法，不可执行</td>
</tr>
</tbody></table>
<p>Foreigner的方法表</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Passenger.toString()</td>
<td>重写Object.toString()</td>
</tr>
<tr>
<td>1</td>
<td>Foreigner.outBound()</td>
<td>重写Passenger.outBound()</td>
</tr>
</tbody></table>
<p>Chinese的方法表</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>方法</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Passenger.toString()</td>
<td>重写Object.toString()</td>
</tr>
<tr>
<td>1</td>
<td>Chinese.outBound()</td>
<td>重写Passenger.outBound()</td>
</tr>
<tr>
<td>2</td>
<td>Chinese.shopping()</td>
<td>购物</td>
</tr>
</tbody></table>
<h2 id="即时编译优化"><a href="#即时编译优化" class="headerlink" title="即时编译优化"></a>即时编译优化</h2><h3 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h3><ol>
<li><strong>加快动态绑定</strong>的优化技术：<strong>缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法</strong></li>
<li>在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接调用该类型所对应的目标方法<ul>
<li>如果没有碰到已缓存的类型，内联缓存则会退化至使用<strong>基于虚方法表的动态绑定</strong></li>
</ul>
</li>
<li>内联缓存实际上并<strong>没有内联目标方法</strong><ul>
<li><strong>任何方法调用除非被内联，否则都会有固定开销</strong></li>
<li>开销<ul>
<li>保存程序在该方法中的<strong>执行位置</strong></li>
<li>新建、压入和弹出新方法所使用的<strong>栈帧</strong></li>
</ul>
</li>
<li>getter&#x2F;setter方法的固定开销所占据的CPU时间甚至超过了方法本身</li>
<li>在<strong>即时编译</strong>中，<strong>方法内联可以消除方法调用的固定开销</strong></li>
</ul>
</li>
</ol>
<h4 id="针对多态的优化"><a href="#针对多态的优化" class="headerlink" title="针对多态的优化"></a>针对多态的优化</h4><ol>
<li>术语<ul>
<li>单态：仅有一种状态的情况</li>
<li>多态：有限数量状态的情况</li>
<li>超多态：在某个具体数值之下，称之为多态，否则，称之为超多态</li>
</ul>
</li>
<li>对于内联缓存，我们也有对应的单态内联缓存、多态内联缓存和超多态内联缓存<ul>
<li>单态内联缓存<ul>
<li>只缓存了一种动态类型以及它所对应的目标方法；比较所缓存的动态类型，如果命中，则调用对应的目标方法</li>
<li>大部分的虚方法调用均是单态的（只有一种动态类型），为了节省内存空间，<strong>JVM只采用单态内联缓存</strong></li>
</ul>
</li>
<li>多态内联缓存（HotSpot中不存在）<ul>
<li>缓存了多个动态类型以及目标方法；逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用相应的目标方法</li>
<li>一般来说，我们会将更热门的动态类型放在前面</li>
</ul>
</li>
</ul>
</li>
<li>当内联缓存没有命中的情况下，JVM需要重新使用<strong>虚方法表</strong>进行动态绑定，有两种选择<ul>
<li>替换单态内联缓存中的记录（<strong>数据局部性原理</strong>）<ul>
<li>最坏情况：每次进行方法调用都轮流替换内联缓存，导致<strong>只有写缓存的额外开销，但没有读缓存对性能提升</strong></li>
<li>可以劣化为超多态内联缓存</li>
</ul>
</li>
<li><strong>超多态内联缓存（JVM的具体实现方式）</strong><ul>
<li>实际上已经<strong>放弃了优化的机会，直接访问虚方法表来动态绑定目标方法</strong></li>
</ul>
</li>
</ul>
</li>
<li>单态内联缓存 -&gt; (无法命中，劣化) -&gt; 超多态内联缓存（直接使用虚方法表来进行动态绑定）<ul>
<li><strong>HotSpot只存在单态内联缓存和超多态内联缓存</strong>，不存在多态内联缓存</li>
</ul>
</li>
</ol>
<h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -XX:CompileCommand=dontinline,*.outBound</span></span><br><span class="line"><span class="type">Passenger</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foreigner</span>();</span><br><span class="line"><span class="type">Passenger</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>();</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">2_000_000_000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">half_count</span> <span class="operator">=</span> count / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">    <span class="type">Passenger</span> <span class="variable">c</span> <span class="operator">=</span> (i &lt; half_count) ? a : b;</span><br><span class="line">    c.outBound();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 超多态内存缓存（方法表）：6700ms</span></span><br><span class="line"><span class="comment">// 单态内联缓存：2315ms</span></span><br><span class="line">log.info(<span class="string">&quot;&#123;&#125;ms&quot;</span>, end - start);</span><br></pre></td></tr></table></figure>

<h3 id="方法内联（跳过，后续介绍）"><a href="#方法内联（跳过，后续介绍）" class="headerlink" title="方法内联（跳过，后续介绍）"></a>方法内联（跳过，后续介绍）</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100010301">深入拆解Java虚拟机</a></p>
<!-- indicate-the-source -->
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css"></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://blog.zhongmingmao.top">zhongmingmao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://blog.zhongmingmao.top/2018/12/17/jvm-basic-invoke/">https://blog.zhongmingmao.top/2018/12/17/jvm-basic-invoke/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">Java</a><a class="post-meta__tags" href="/tags/jvm/">JVM</a></div><div class="post-share"><div class="social-share" data-image="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-18.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2018/12/18/jvm-basic-bridge-method/" title="JVM基础 -- 桥接方法"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-9.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">JVM基础 -- 桥接方法</div></div><div class="info-2"><div class="info-item-1">背景Java语言的重写与JVM的重写并不一致，当在Java语言中为重写而在JVM中为非重写，编译器会通过生成桥接方法来实现Java中的重写语义 桥接方法 – 返回类型Java代码1234567891011121314151617181920@Slf4jpublic class Father &#123;    public Number work() &#123;        return 1.0;    &#125;    public static void main(String[] args) &#123;        Father father = new Son();        // 实际调用的是桥接方法        Number work = father.work();        log.info(&quot;&#123;&#125;&quot;, work);    &#125;&#125;class Son extends Father &#123;    @Override    public Double work() &#123;        return 2....</div></div></div></a><a class="pagination-related" href="/2018/12/16/jvm-basic-load-class/" title="JVM基础 -- 类加载"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-21.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">JVM基础 -- 类加载</div></div><div class="info-2"><div class="info-item-1">引用类型 类（字节流） 接口（字节流） 数组类（由JVM直接生成） 泛型参数（类型擦除，伪泛型）  类加载过程加载 加载：查找字节流，并且据此创建类的过程 对于数组类，没有对应的字节流，而是由JVM直接生成的 对于其他类而言，JVM需要借助类加载器来完成查找字节流的过程      类加载器 启动类加载器（boot class loader）：由C++实现，没有对应的Java对象，在Java中只能用null来指代 除了启动类加载器外，其他的类加载器都是java.lang.ClassLoader的子类，有对应的Java对象 这些类加载器需要先由另一个类加载器（如启动类加载器），加载至Java虚拟机中，方能执行类加载   双亲委派模型 每当一个类加载器接收到加载请求时，会先将请求转发给父类加载器 在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试自己加载   Before Java9 启动类加载器（boot class loader）：负责加载最基础、最重要的类（-Xbootclasspath） 扩展类加载器（extension class loader）：父类加载器为启动类加载器，负责加载相对次要、...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/02/22/jvm-bytecode-manipulation-asm-introduction/" title="ASM - Introduction"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-22.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-22</div><div class="info-item-2">ASM - Introduction</div></div><div class="info-2"><div class="info-item-1">Glance ASM is an all purpose Java bytecode manipulation and analysis framework. It can be used to modify existing classes or to dynamically generate classes, directly in binary form.   ASM provides some common bytecode transformations and analysis algorithms from which custom complex transformations and code analysis tools can be built. ASM offers similar functionality as other Java bytecode frameworks, but is focused on performance. Because it was designed and implemented to be as small and as fast as p...</div></div></div></a><a class="pagination-related" href="/2022/02/11/jvm-bytecode-manipulation-javassist/" title="Bytecode Manipulation - Javassist"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-1.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-11</div><div class="info-item-2">Bytecode Manipulation - Javassist</div></div><div class="info-2"><div class="info-item-1">概要 Unlike other similar bytecode editors, Javassist provides two levels of API: source level and bytecode level.  生成字节码1234567891011121314151617package me.zhongmingmao.javassist;public class Point &#123;  private int x;  private int y;  public Point(int x, int y) &#123;    this.x = x;    this.y = y;  &#125;  public void move(int x, int y) &#123;    this.x = x;    this.y = y;  &#125;&#125;  12$ javac me/zhongmingmao/javassist/Point.java$ javap -v me.zhongmingmao.javassist.Point    123456789101112131415161...</div></div></div></a><a class="pagination-related" href="/2022/02/10/jvm-bytecode-manipulation-java-agent-practice/" title="Bytecode Manipulation - Java Agent Practice"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-20.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-10</div><div class="info-item-2">Bytecode Manipulation - Java Agent Practice</div></div><div class="info-2"><div class="info-item-1">概念Instrument Instrument 是 JVM 提供的一个可以修改已加载类的类库，依赖于 JVMTI 的 Attach API 机制 要使用 Instrument 的类修改功能，需要实现 java.lang.instrument.ClassFileTransformer 接口 可以在 ClassFileTransformer#transform 中利用 ASM 或者 Byte Buddy 等工具对字节码进行操作   Instrument 通过与 Java Agent 结合来注入到 JVM 中  JVMTI &amp; Agent JPDA（Java Platform Debugger Architecture）是 JDK 标准，必须实现 如果 JVM 启动时开启了 JPDA，那么类是允许被重新加载的 已加载的旧版类信息被卸载，然后重新加载新版本的类   JVMTI 是 JVM 提供的一套对 JVM 进行操作的工具接口，Agent 是 JVMTI 的一种实现 Attach API 的作用：提供 JVM 进程间通信的能力 Attach 后，目标 JVM 在运行时走到 Agent 中定义的 age...</div></div></div></a><a class="pagination-related" href="/2019/09/13/java-performance-jvm-heap-allocation/" title="Java性能 -- JVM堆内存分配"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-21.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-13</div><div class="info-item-2">Java性能 -- JVM堆内存分配</div></div><div class="info-2"><div class="info-item-1">JVM内存分配性能问题 JVM内存分配不合理最直接的表现就是频繁的GC，这会导致上下文切换，从而降低系统的吞吐量，增加系统的响应时间  对象在堆中的生命周期 在JVM内存模型的堆中，堆被划分为新生代和老年代 新生代又被进一步划分为Eden区和Survivor区，Survivor区由From Survivor和To Survivor组成   当创建一个对象时，对象会被优先分配到新生代的Eden区 此时JVM会给对象定义一个对象年轻计数器（-XX:MaxTenuringThreshold）   当Eden空间不足时，JVM将执行新生代的垃圾回收（Minor GC） JVM会把存活的对象转移到Survivor中，并且对象年龄+1 对象在Survivor中同样也会经历Minor GC，每经历一次Minor GC，对象年龄都会+1   如果分配的对象超过了-XX:PetenureSizeThreshold，对象会直接被分配到老年代    查看JVM堆内存分配 在默认不配置JVM堆内存大小的情况下，JVM根据默认值来配置当前内存大小 在JDK 1.7中，默认情况下新生代和老年代的比例是1:2，可以通过–XX:New...</div></div></div></a><a class="pagination-related" href="/2019/09/11/java-performance-gc/" title="Java性能 -- GC"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-16.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-11</div><div class="info-item-2">Java性能 -- GC</div></div><div class="info-2"><div class="info-item-1">GC机制回收区域 JVM的内存区域中，程序计数器、虚拟机栈、本地方法栈是线程私有，随线程的创建而创建，销毁而销毁 栈中的栈帧随着方法的进入和退出进行入栈和出栈操作，每个栈帧分配多少内存基本是在类结构确定下来时就已知 因此，这三个区域的内存分配和回收都是具有确定性的   堆中的回收主要是对象回收，方法区的回收主要是废弃常量和无用类的回收    回收时机 当一个对象不再被引用，就代表该对象可以被回收 引用计数法：实现简单，判断效率高，但存在循环引用的问题 可达性分析算法：HotSpot VM     引用类型 功能特点    强引用（Strong Reference） 被强引用关联的对象，永远不会被垃圾回收器回收   软引用（Soft Reference） 被软引用关联的对象，只有当系统将要发生内存溢出时，才会去回收软引用关联的对象   弱引用（Weak Reference） 只被弱引用关联的对象，只要发生GC事件，就会被回收   虚引用（Phantom Reference） 被虚引用关联的对象，唯一作用是在这个对象被回收时收到一个系统通知   回收特性 自动性 Java提供了一个系统级的线程来跟踪每一块分...</div></div></div></a><a class="pagination-related" href="/2019/09/09/java-performance-jit/" title="Java性能 -- JIT"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/go-20.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-09</div><div class="info-item-2">Java性能 -- JIT</div></div><div class="info-2"><div class="info-item-1">编译 前端编译：即常见的**.java文件被编译成.class文件**的过程 运行时编译：机器无法直接运行Java生成的字节码，在运行时，JIT或者解释器会将字节码转换为机器码 类文件在运行时被进一步编译，可以变成高度优化的机器代码   C&#x2F;C++编译器的所有优化都是在编译期完成的，运行期的性能监控仅作为基础的优化措施是无法进行的 JIT编译器是JVM中运行时编译最重要的部分之一    编译 &#x2F; 加载 &#x2F; 执行  类编译 javac：将.java文件编译成.class文件 javap：反编译.class文件，重点关注常量池和方法表集合 常量池主要记录的是类文件中出现的字面量和符号引用 字面量：字符串常量、基本类型的常量 符号引用：类和接口的全限定名、类引用、方法引用、成员变量引用   方法表集合 方法的字节码、方法访问权限、方法名索引、描述符索引、JVM执行指令、属性集合等        类加载 当一个类被创建实例或者被其他对象引用时，JVM如果没有加载过该类，会通过类加载器将**.class文件加载到内存**中 不同的实现类由不同的类加载器加载 JDK中的本地方法类一般由...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://zhongmingmao-1253868755.cos.ap-guangzhou.myqcloud.com/z.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">zhongmingmao</div><div class="author-info-description">Focus on Infrastructure.</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">641</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">191</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">83</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="mailto:zhongmingmao0625@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Things are always unexpected!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-%E9%87%8D%E5%86%99"><span class="toc-number">1.</span> <span class="toc-text">重载+重写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">1.1.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99"><span class="toc-number">1.2.</span> <span class="toc-text">重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">2.</span> <span class="toc-text">静态绑定与+动态绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">2.1.</span> <span class="toc-text">重载不一定是静态绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">Java代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">字节码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">2.2.</span> <span class="toc-text">重写不一定是动态绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%BB%A3%E7%A0%81-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">Java代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">字节码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">3.</span> <span class="toc-text">调用相关的指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%8C%87%E4%BB%A4"><span class="toc-number">3.1.</span> <span class="toc-text">具体指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">定位目标方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">调用指令的符号引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E7%9A%84%E6%9F%A5%E6%89%BE%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.3.1.</span> <span class="toc-text">目标方法的查找步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">虚方法调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8%EF%BC%88%E9%93%BE%E6%8E%A5-%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">虚方法表（链接-准备阶段）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">即时编译优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E7%BC%93%E5%AD%98"><span class="toc-number">6.1.</span> <span class="toc-text">内联缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">6.1.1.</span> <span class="toc-text">针对多态的优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">6.1.2.</span> <span class="toc-text">性能对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94%EF%BC%88%E8%B7%B3%E8%BF%87%EF%BC%8C%E5%90%8E%E7%BB%AD%E4%BB%8B%E7%BB%8D%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">方法内联（跳过，后续介绍）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/23/cloud-native-observability-prometheus-concepts/" title="Observability - Prometheus Concepts"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://observability-1253868755.cos.ap-guangzhou.myqcloud.com/prometheus-concepts.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Observability - Prometheus Concepts"/></a><div class="content"><a class="title" href="/2025/01/23/cloud-native-observability-prometheus-concepts/" title="Observability - Prometheus Concepts">Observability - Prometheus Concepts</a><time datetime="2025-01-22T16:06:25.000Z" title="Created 2025-01-23 00:06:25">2025-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/22/cloud-native-observability-prometheus-introduction/" title="Observability - Prometheus Introduction"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://observability-1253868755.cos.ap-guangzhou.myqcloud.com/prometheus.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Observability - Prometheus Introduction"/></a><div class="content"><a class="title" href="/2025/01/22/cloud-native-observability-prometheus-introduction/" title="Observability - Prometheus Introduction">Observability - Prometheus Introduction</a><time datetime="2025-01-21T16:06:25.000Z" title="Created 2025-01-22 00:06:25">2025-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/21/cloud-native-observability-opentelemetry-java-zero-code/" title="Observability - OpenTelemetry Java Zero Code"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://observability-1253868755.cos.ap-guangzhou.myqcloud.com/otel-java-agent.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Observability - OpenTelemetry Java Zero Code"/></a><div class="content"><a class="title" href="/2025/01/21/cloud-native-observability-opentelemetry-java-zero-code/" title="Observability - OpenTelemetry Java Zero Code">Observability - OpenTelemetry Java Zero Code</a><time datetime="2025-01-20T16:06:25.000Z" title="Created 2025-01-21 00:06:25">2025-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/20/cloud-native-observability-opentelemetry-java/" title="Observability - OpenTelemetry Java"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://observability-1253868755.cos.ap-guangzhou.myqcloud.com/otel-java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Observability - OpenTelemetry Java"/></a><div class="content"><a class="title" href="/2025/01/20/cloud-native-observability-opentelemetry-java/" title="Observability - OpenTelemetry Java">Observability - OpenTelemetry Java</a><time datetime="2025-01-19T16:06:25.000Z" title="Created 2025-01-20 00:06:25">2025-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/19/ai-agent-overview-mcp/" title="AI Agent - MCP Overview"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ai-agent-1253868755.cos.ap-guangzhou.myqcloud.com/mcp.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI Agent - MCP Overview"/></a><div class="content"><a class="title" href="/2025/01/19/ai-agent-overview-mcp/" title="AI Agent - MCP Overview">AI Agent - MCP Overview</a><time datetime="2025-01-18T16:06:25.000Z" title="Created 2025-01-19 00:06:25">2025-01-19</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2015 - 2025 By zhongmingmao</span></div><div class="footer_custom_text">Life is like a box of chocolates. You can't know what you'll eat until you open it.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script></div></body></html>